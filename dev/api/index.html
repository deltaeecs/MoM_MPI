<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MoM_Kernels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://deltaeecs.github.io/MoM_MPI.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MoM_Kernels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MoM_Kernels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/deltaeecs/MoM_MPI.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#MoM_Basics.EDGEVmINTriVsID"><code>MoM_Basics.EDGEVmINTriVsID</code></a></li><li><a href="#MoM_Basics.EDGEVpINTriVsID"><code>MoM_Basics.EDGEVpINTriVsID</code></a></li><li><a href="#MoM_Basics.GQ1DID2GQ3DIDVector"><code>MoM_Basics.GQ1DID2GQ3DIDVector</code></a></li><li><a href="#MoM_Basics.GQPNQuad"><code>MoM_Basics.GQPNQuad</code></a></li><li><a href="#MoM_Basics.GQPNQuad1D"><code>MoM_Basics.GQPNQuad1D</code></a></li><li><a href="#MoM_Basics.GQPNQuad1DSSglr"><code>MoM_Basics.GQPNQuad1DSSglr</code></a></li><li><a href="#MoM_Basics.GQPNQuad1DSglr"><code>MoM_Basics.GQPNQuad1DSglr</code></a></li><li><a href="#MoM_Basics.GQPNQuadSSglr"><code>MoM_Basics.GQPNQuadSSglr</code></a></li><li><a href="#MoM_Basics.GQPNQuadSglr"><code>MoM_Basics.GQPNQuadSglr</code></a></li><li><a href="#MoM_Basics.Params"><code>MoM_Basics.Params</code></a></li><li><a href="#MoM_Basics.Precision"><code>MoM_Basics.Precision</code></a></li><li><a href="#MoM_Basics.QuadGQInfo"><code>MoM_Basics.QuadGQInfo</code></a></li><li><a href="#MoM_Basics.QuadGQInfoSSglr"><code>MoM_Basics.QuadGQInfoSSglr</code></a></li><li><a href="#MoM_Basics.QuadGQInfoSglr"><code>MoM_Basics.QuadGQInfoSglr</code></a></li><li><a href="#MoM_Basics.SimulationParams"><code>MoM_Basics.SimulationParams</code></a></li><li><a href="#MoM_Basics.VSBFTypes"><code>MoM_Basics.VSBFTypes</code></a></li><li><a href="#MoM_Basics.Vec3IdxCircle"><code>MoM_Basics.Vec3IdxCircle</code></a></li><li><a href="#MoM_Basics.facen2OppositeID"><code>MoM_Basics.facen2OppositeID</code></a></li><li><a href="#MoM_Basics.facesVertIDs"><code>MoM_Basics.facesVertIDs</code></a></li><li><a href="#MoM_Basics.memory"><code>MoM_Basics.memory</code></a></li><li><a href="#MoM_Basics.oppFacesVertIDs"><code>MoM_Basics.oppFacesVertIDs</code></a></li><li><a href="#MoM_Basics.timer"><code>MoM_Basics.timer</code></a></li><li><a href="#MoM_Basics.uv2FreeVnsDict"><code>MoM_Basics.uv2FreeVnsDict</code></a></li><li><a href="#MoM_Kernels.GeosInterval"><code>MoM_Kernels.GeosInterval</code></a></li><li><a href="#MoM_Kernels.MLFMAParams"><code>MoM_Kernels.MLFMAParams</code></a></li><li><a href="#MoM_Kernels.ParallelParams"><code>MoM_Kernels.ParallelParams</code></a></li><li><a href="#MoM_Kernels.SSCg"><code>MoM_Kernels.SSCg</code></a></li><li><a href="#MoM_Kernels.SSCgdivnp2"><code>MoM_Kernels.SSCgdivnp2</code></a></li><li><a href="#MoM_Kernels.VSC₃ⁿ"><code>MoM_Kernels.VSC₃ⁿ</code></a></li><li><a href="#MoM_Basics.AbstractAntennaArray"><code>MoM_Basics.AbstractAntennaArray</code></a></li><li><a href="#MoM_Basics.AntennaArray"><code>MoM_Basics.AntennaArray</code></a></li><li><a href="#MoM_Basics.AntennaArray-Union{Tuple{AbstractArray{AT, N}}, Tuple{N}, Tuple{AT}} where {AT, N}"><code>MoM_Basics.AntennaArray</code></a></li><li><a href="#MoM_Basics.AntennaType"><code>MoM_Basics.AntennaType</code></a></li><li><a href="#MoM_Basics.BasisFunctionType"><code>MoM_Basics.BasisFunctionType</code></a></li><li><a href="#MoM_Basics.ConstBasisFunction"><code>MoM_Basics.ConstBasisFunction</code></a></li><li><a href="#MoM_Basics.ExcitingSource"><code>MoM_Basics.ExcitingSource</code></a></li><li><a href="#MoM_Basics.ExcitingSources"><code>MoM_Basics.ExcitingSources</code></a></li><li><a href="#MoM_Basics.HexahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.HexahedraInfo</code></a></li><li><a href="#MoM_Basics.HexahedraInfo"><code>MoM_Basics.HexahedraInfo</code></a></li><li><a href="#MoM_Basics.HexahedraMesh"><code>MoM_Basics.HexahedraMesh</code></a></li><li><a href="#MoM_Basics.LinearBasisFunction"><code>MoM_Basics.LinearBasisFunction</code></a></li><li><a href="#MoM_Basics.MagneticDipole"><code>MoM_Basics.MagneticDipole</code></a></li><li><a href="#MoM_Basics.MagneticDipole"><code>MoM_Basics.MagneticDipole</code></a></li><li><a href="#MoM_Basics.MagneticDipole-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Basics.MagneticDipole</code></a></li><li><a href="#MoM_Basics.MeshDataType"><code>MoM_Basics.MeshDataType</code></a></li><li><a href="#MoM_Basics.MeshFormat"><code>MoM_Basics.MeshFormat</code></a></li><li><a href="#MoM_Basics.MeshNodeTriTetraHexa"><code>MoM_Basics.MeshNodeTriTetraHexa</code></a></li><li><a href="#MoM_Basics.NasMesh"><code>MoM_Basics.NasMesh</code></a></li><li><a href="#MoM_Basics.PWC"><code>MoM_Basics.PWC</code></a></li><li><a href="#MoM_Basics.PWC-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.PWC</code></a></li><li><a href="#MoM_Basics.ParamsType"><code>MoM_Basics.ParamsType</code></a></li><li><a href="#MoM_Basics.ParamsType-Union{Tuple{CT}, Tuple{FT}} where {FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Basics.ParamsType</code></a></li><li><a href="#MoM_Basics.PlaneWave"><code>MoM_Basics.PlaneWave</code></a></li><li><a href="#MoM_Basics.PlaneWave-Union{Tuple{FT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where FT"><code>MoM_Basics.PlaneWave</code></a></li><li><a href="#MoM_Basics.PrecisionT"><code>MoM_Basics.PrecisionT</code></a></li><li><a href="#MoM_Basics.Quads4Hexa-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.Quads4Hexa</code></a></li><li><a href="#MoM_Basics.Quads4Hexa"><code>MoM_Basics.Quads4Hexa</code></a></li><li><a href="#MoM_Basics.Quads4Hexa-Union{Tuple{FT}, Tuple{FT, FT}} where FT"><code>MoM_Basics.Quads4Hexa</code></a></li><li><a href="#MoM_Basics.RBF"><code>MoM_Basics.RBF</code></a></li><li><a href="#MoM_Basics.RBF-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.RBF</code></a></li><li><a href="#MoM_Basics.RWG"><code>MoM_Basics.RWG</code></a></li><li><a href="#MoM_Basics.RWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.RWG</code></a></li><li><a href="#MoM_Basics.SWG"><code>MoM_Basics.SWG</code></a></li><li><a href="#MoM_Basics.SWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.SWG</code></a></li><li><a href="#MoM_Basics.SimulationParamsType"><code>MoM_Basics.SimulationParamsType</code></a></li><li><a href="#MoM_Basics.SimulationParamsType-Tuple{}"><code>MoM_Basics.SimulationParamsType</code></a></li><li><a href="#MoM_Basics.SurfaceCellType"><code>MoM_Basics.SurfaceCellType</code></a></li><li><a href="#MoM_Basics.TetrahedraInfo"><code>MoM_Basics.TetrahedraInfo</code></a></li><li><a href="#MoM_Basics.TetrahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.TetrahedraInfo</code></a></li><li><a href="#MoM_Basics.TetrahedraMesh"><code>MoM_Basics.TetrahedraMesh</code></a></li><li><a href="#MoM_Basics.TriangleInfo-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.TriangleInfo</code></a></li><li><a href="#MoM_Basics.TriangleInfo"><code>MoM_Basics.TriangleInfo</code></a></li><li><a href="#MoM_Basics.TriangleMesh"><code>MoM_Basics.TriangleMesh</code></a></li><li><a href="#MoM_Basics.Tris4Tetra-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.Tris4Tetra</code></a></li><li><a href="#MoM_Basics.Tris4Tetra"><code>MoM_Basics.Tris4Tetra</code></a></li><li><a href="#MoM_Basics.VSBFTstruct"><code>MoM_Basics.VSBFTstruct</code></a></li><li><a href="#MoM_Basics.VSCellType"><code>MoM_Basics.VSCellType</code></a></li><li><a href="#MoM_Basics.VecCart2SphereMat"><code>MoM_Basics.VecCart2SphereMat</code></a></li><li><a href="#MoM_Basics.VecCart2SphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.VecCart2SphereMat</code></a></li><li><a href="#MoM_Basics.VolumeCellType"><code>MoM_Basics.VolumeCellType</code></a></li><li><a href="#MoM_Basics.r̂θϕInfo"><code>MoM_Basics.r̂θϕInfo</code></a></li><li><a href="#MoM_Basics.r̂θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real"><code>MoM_Basics.r̂θϕInfo</code></a></li><li><a href="#MoM_Basics.r̂θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.r̂θϕInfo</code></a></li><li><a href="#MoM_Basics.θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfo</code></a></li><li><a href="#MoM_Basics.θϕInfo"><code>MoM_Basics.θϕInfo</code></a></li><li><a href="#MoM_Basics.θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfo</code></a></li><li><a href="#MoM_Basics.∠Info"><code>MoM_Basics.∠Info</code></a></li><li><a href="#MoM_Kernels.CubeInfo"><code>MoM_Kernels.CubeInfo</code></a></li><li><a href="#MoM_Kernels.GLPolesInfo"><code>MoM_Kernels.GLPolesInfo</code></a></li><li><a href="#MoM_Kernels.GeosIntervalType"><code>MoM_Kernels.GeosIntervalType</code></a></li><li><a href="#MoM_Kernels.LagrangeInterp1StepInfo"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterpInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterpInfo"><code>MoM_Kernels.LagrangeInterpInfo</code></a></li><li><a href="#MoM_Kernels.LevelInfo"><code>MoM_Kernels.LevelInfo</code></a></li><li><a href="#MoM_Kernels.MLFMAParamsType"><code>MoM_Kernels.MLFMAParamsType</code></a></li><li><a href="#MoM_Kernels.MLMFAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.MLMFAIterator</code></a></li><li><a href="#MoM_Kernels.MLMFAIterator"><code>MoM_Kernels.MLMFAIterator</code></a></li><li><a href="#MoM_Kernels.MatrixChunk"><code>MoM_Kernels.MatrixChunk</code></a></li><li><a href="#MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number"><code>MoM_Kernels.MatrixChunk</code></a></li><li><a href="#MoM_Kernels.OctreeInfo"><code>MoM_Kernels.OctreeInfo</code></a></li><li><a href="#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.OctreeInfo</code></a></li><li><a href="#MoM_Kernels.PartitionedVector"><code>MoM_Kernels.PartitionedVector</code></a></li><li><a href="#MoM_Kernels.SAIChunkPrec"><code>MoM_Kernels.SAIChunkPrec</code></a></li><li><a href="#MoM_Kernels.SAIPrec"><code>MoM_Kernels.SAIPrec</code></a></li><li><a href="#MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.ZnearChunksStruct</code></a></li><li><a href="#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number"><code>MoM_Kernels.ZnearChunksStruct</code></a></li><li><a href="#MoM_Kernels.ZnearT"><code>MoM_Kernels.ZnearT</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{FT}, Tuple{T}, Tuple{VecCart2SphereMat{FT}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where {T&lt;:Number, FT&lt;:AbstractFloat}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}"><code>Base.convert</code></a></li><li><a href="#Base.eltype-Tuple{IncompleteLU.ILUFactorization}"><code>Base.eltype</code></a></li><li><a href="#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.getindex</code></a></li><li><a href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.setindex!</code></a></li><li><a href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.setindex!</code></a></li><li><a href="#Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization"><code>Base.size</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{Any, MLMFAIterator, Any}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, Any}} where {T, V}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{AbstractVector, MLMFAIterator, AbstractVector, Number, Number}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#MoM_Basics._nastran_string_to_float-Tuple{Any}"><code>MoM_Basics._nastran_string_to_float</code></a></li><li><a href="#MoM_Basics.acrossbcrossc-Tuple{Any, Any, Any}"><code>MoM_Basics.acrossbcrossc</code></a></li><li><a href="#MoM_Basics.add_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real"><code>MoM_Basics.add_phase!</code></a></li><li><a href="#MoM_Basics.antennaArray"><code>MoM_Basics.antennaArray</code></a></li><li><a href="#MoM_Basics.boundaryRBF-Tuple{Meshes.Hexahedron}"><code>MoM_Basics.boundaryRBF</code></a></li><li><a href="#MoM_Basics.byte2other-Tuple{Any, Any}"><code>MoM_Basics.byte2other</code></a></li><li><a href="#MoM_Basics.cart2sphere-Union{Tuple{Vararg{T, 3}}, Tuple{T}} where T"><code>MoM_Basics.cart2sphere</code></a></li><li><a href="#MoM_Basics.cart2sphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.cart2sphereMat</code></a></li><li><a href="#MoM_Basics.constructFloat2IndexDict-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.constructFloat2IndexDict</code></a></li><li><a href="#MoM_Basics.constructGQ1DID2GQ3DIDVector-Tuple{Any}"><code>MoM_Basics.constructGQ1DID2GQ3DIDVector</code></a></li><li><a href="#MoM_Basics.dist-Union{Tuple{FT}, Tuple{AbstractVector{FT}, AbstractVector{FT}}} where FT&lt;:AbstractFloat"><code>MoM_Basics.dist</code></a></li><li><a href="#MoM_Basics.eulerRMat2αβγ-Tuple{Any}"><code>MoM_Basics.eulerRMat2αβγ</code></a></li><li><a href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT}, Tuple{FT, FT, Symbol}} where FT&lt;:AbstractFloat"><code>MoM_Basics.eulerRotationMat</code></a></li><li><a href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT, FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerRotationMat</code></a></li><li><a href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerRotationMat</code></a></li><li><a href="#MoM_Basics.eulerZunit-Union{Tuple{FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerZunit</code></a></li><li><a href="#MoM_Basics.getBFTfromCellT-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Basics.getBFTfromCellT</code></a></li><li><a href="#MoM_Basics.getBFsFromMeshData-Tuple{Any}"><code>MoM_Basics.getBFsFromMeshData</code></a></li><li><a href="#MoM_Basics.getCellsBFs-Tuple{Any, Any}"><code>MoM_Basics.getCellsBFs</code></a></li><li><a href="#MoM_Basics.getCellsBFsFromFileName-Tuple{Any}"><code>MoM_Basics.getCellsBFsFromFileName</code></a></li><li><a href="#MoM_Basics.getCellsFromFileName-Tuple{Any}"><code>MoM_Basics.getCellsFromFileName</code></a></li><li><a href="#MoM_Basics.getConnectionMatrix-Tuple{Any}"><code>MoM_Basics.getConnectionMatrix</code></a></li><li><a href="#MoM_Basics.getFreeVIDFromGQ3DID-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DID</code></a></li><li><a href="#MoM_Basics.getFreeVIDFromGQ3DIDSSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DIDSSglr</code></a></li><li><a href="#MoM_Basics.getFreeVIDFromGQ3DIDSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DIDSglr</code></a></li><li><a href="#MoM_Basics.getFreeVns-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVns</code></a></li><li><a href="#MoM_Basics.getFreeVnsSSglr-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVnsSSglr</code></a></li><li><a href="#MoM_Basics.getFreeVnsSglr-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVnsSglr</code></a></li><li><a href="#MoM_Basics.getGQPHexa-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexa</code></a></li><li><a href="#MoM_Basics.getGQPHexaSSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexaSSglr</code></a></li><li><a href="#MoM_Basics.getGQPHexaSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexaSglr</code></a></li><li><a href="#MoM_Basics.getGQPQuad-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuad</code></a></li><li><a href="#MoM_Basics.getGQPQuadSSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuadSSglr</code></a></li><li><a href="#MoM_Basics.getGQPQuadSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuadSglr</code></a></li><li><a href="#MoM_Basics.getGQPTetra-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTetra</code></a></li><li><a href="#MoM_Basics.getGQPTetraSglr-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTetraSglr</code></a></li><li><a href="#MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTri</code></a></li><li><a href="#MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTri</code></a></li><li><a href="#MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTriSglr</code></a></li><li><a href="#MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTriSglr</code></a></li><li><a href="#MoM_Basics.getHexasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Symbol}} where {IT, FT}"><code>MoM_Basics.getHexasInfo</code></a></li><li><a href="#MoM_Basics.getMeshData-Tuple{String}"><code>MoM_Basics.getMeshData</code></a></li><li><a href="#MoM_Basics.getNodeTriTetraFekoNas-Union{Tuple{T}, Tuple{ST}, Tuple{ST, Type{T}}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getNodeTriTetraFekoNas</code></a></li><li><a href="#MoM_Basics.getNodeTriTetraHexaNas-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getNodeTriTetraHexaNas</code></a></li><li><a href="#MoM_Basics.getTetrasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Symbol}} where {IT, FT}"><code>MoM_Basics.getTetrasInfo</code></a></li><li><a href="#MoM_Basics.getTriangleInfo-Union{Tuple{TriangleMesh{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}"><code>MoM_Basics.getTriangleInfo</code></a></li><li><a href="#MoM_Basics.getdatNodeElementParam-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getdatNodeElementParam</code></a></li><li><a href="#MoM_Basics.globalObs2LocalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT"><code>MoM_Basics.globalObs2LocalObs</code></a></li><li><a href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a></li><li><a href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a></li><li><a href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a></li><li><a href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a></li><li><a href="#MoM_Basics.greenfunc-Tuple{T} where T&lt;:AbstractFloat"><code>MoM_Basics.greenfunc</code></a></li><li><a href="#MoM_Basics.initialize_time_and_mem-Tuple{}"><code>MoM_Basics.initialize_time_and_mem</code></a></li><li><a href="#MoM_Basics.inputBasicParameters-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.inputBasicParameters</code></a></li><li><a href="#MoM_Basics.localObs2GlobalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT"><code>MoM_Basics.localObs2GlobalObs</code></a></li><li><a href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a></li><li><a href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a></li><li><a href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a></li><li><a href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a></li><li><a href="#MoM_Basics.modiParams!-NTuple{16, Any}"><code>MoM_Basics.modiParams!</code></a></li><li><a href="#MoM_Basics.modiSimulationParams!-Tuple{}"><code>MoM_Basics.modiSimulationParams!</code></a></li><li><a href="#MoM_Basics.nodes2Poles-Union{Tuple{Matrix{FT}}, Tuple{FT}} where FT"><code>MoM_Basics.nodes2Poles</code></a></li><li><a href="#MoM_Basics.radiationDirectionCoeff-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationDirectionCoeff</code></a></li><li><a href="#MoM_Basics.radiationIntegralL0-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationIntegralL0</code></a></li><li><a href="#MoM_Basics.radiationIntensityU_m-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationIntensityU_m</code></a></li><li><a href="#MoM_Basics.radiationPower-Tuple{MagneticDipole}"><code>MoM_Basics.radiationPower</code></a></li><li><a href="#MoM_Basics.random_rhat-Tuple{}"><code>MoM_Basics.random_rhat</code></a></li><li><a href="#MoM_Basics.record_BFsInfo-Tuple{Symbol, Int64}"><code>MoM_Basics.record_BFsInfo</code></a></li><li><a href="#MoM_Basics.record_CellInfo"><code>MoM_Basics.record_CellInfo</code></a></li><li><a href="#MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!</code></a></li><li><a href="#MoM_Basics.rwgbfnohalfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.rwgbfnohalfConstructerTrianglesInfoModifiers!</code></a></li><li><a href="#MoM_Basics.saveSimulationParams-Tuple{}"><code>MoM_Basics.saveSimulationParams</code></a></li><li><a href="#MoM_Basics.second_to_other-Tuple{Any, Any}"><code>MoM_Basics.second_to_other</code></a></li><li><a href="#MoM_Basics.selectFreeVnID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnID</code></a></li><li><a href="#MoM_Basics.selectFreeVnSSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnSSglrID</code></a></li><li><a href="#MoM_Basics.selectFreeVnSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnSglrID</code></a></li><li><a href="#MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:VSCellType, CT&lt;:Complex}"><code>MoM_Basics.setGeosPermittivity!</code></a></li><li><a href="#MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:TriangleInfo, CT&lt;:Complex}"><code>MoM_Basics.setGeosPermittivity!</code></a></li><li><a href="#MoM_Basics.setHexaCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}, HexahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setHexaCoor!</code></a></li><li><a href="#MoM_Basics.setHexaParam!-Union{Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setHexaParam!</code></a></li><li><a href="#MoM_Basics.setPrecision!-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>MoM_Basics.setPrecision!</code></a></li><li><a href="#MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:RBF}}} where {IT, FT, CT}"><code>MoM_Basics.setQuad4Hexas!</code></a></li><li><a href="#MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}"><code>MoM_Basics.setQuad4Hexas!</code></a></li><li><a href="#MoM_Basics.setTetraCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}, MoM_Basics.TetrahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setTetraCoor!</code></a></li><li><a href="#MoM_Basics.setTetraParam!-Union{Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setTetraParam!</code></a></li><li><a href="#MoM_Basics.setTriParam!-Tuple{TriangleInfo}"><code>MoM_Basics.setTriParam!</code></a></li><li><a href="#MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}"><code>MoM_Basics.setTriangles4Tetras!</code></a></li><li><a href="#MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:SWG}}} where {IT, FT, CT}"><code>MoM_Basics.setTriangles4Tetras!</code></a></li><li><a href="#MoM_Basics.setTricoor!-Union{Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, TriangleMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.setTricoor!</code></a></li><li><a href="#MoM_Basics.setdiffArray!"><code>MoM_Basics.setdiffArray!</code></a></li><li><a href="#MoM_Basics.setδκ!-Union{Tuple{AbstractVector{VT}}, Tuple{VT}} where VT&lt;:VolumeCellType"><code>MoM_Basics.setδκ!</code></a></li><li><a href="#MoM_Basics.setδκ!-Union{Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Basics.setδκ!</code></a></li><li><a href="#MoM_Basics.show_memory_time"><code>MoM_Basics.show_memory_time</code></a></li><li><a href="#MoM_Basics.sincmath-Tuple{T} where T&lt;:Number"><code>MoM_Basics.sincmath</code></a></li><li><a href="#MoM_Basics.sourceEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, AbstractVector{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}"><code>MoM_Basics.sourceEfield</code></a></li><li><a href="#MoM_Basics.sourceEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceEfield</code></a></li><li><a href="#MoM_Basics.sourceEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceEfield</code></a></li><li><a href="#MoM_Basics.sourceEfield-Tuple{PlaneWave, Any}"><code>MoM_Basics.sourceEfield</code></a></li><li><a href="#MoM_Basics.sourceFarEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, r̂θϕInfo{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}"><code>MoM_Basics.sourceFarEfield</code></a></li><li><a href="#MoM_Basics.sourceFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceFarEfield</code></a></li><li><a href="#MoM_Basics.sourceFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceFarEfield</code></a></li><li><a href="#MoM_Basics.sourceHfield-Tuple{PlaneWave, Any}"><code>MoM_Basics.sourceHfield</code></a></li><li><a href="#MoM_Basics.sourceLocalEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceLocalEfield</code></a></li><li><a href="#MoM_Basics.sourceLocalEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceLocalEfield</code></a></li><li><a href="#MoM_Basics.sourceLocalFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceLocalFarEfield</code></a></li><li><a href="#MoM_Basics.sourceLocalFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceLocalFarEfield</code></a></li><li><a href="#MoM_Basics.sphere2cart-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>MoM_Basics.sphere2cart</code></a></li><li><a href="#MoM_Basics.updateVSBFTParams!-Tuple{}"><code>MoM_Basics.updateVSBFTParams!</code></a></li><li><a href="#MoM_Basics.updateVSBFTypes!-Tuple{}"><code>MoM_Basics.updateVSBFTypes!</code></a></li><li><a href="#MoM_Basics.update_orient!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}, Tuple{MagneticDipole{FT}, Any, Any}} where FT&lt;:Real"><code>MoM_Basics.update_orient!</code></a></li><li><a href="#MoM_Basics.update_orient!-Tuple{AT} where AT&lt;:AbstractAntennaArray"><code>MoM_Basics.update_orient!</code></a></li><li><a href="#MoM_Basics.update_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real"><code>MoM_Basics.update_phase!</code></a></li><li><a href="#MoM_Basics.update_phase!-Union{Tuple{AT}, Tuple{AT, Any}} where AT&lt;:AbstractAntennaArray"><code>MoM_Basics.update_phase!</code></a></li><li><a href="#MoM_Basics.θϕInfofromCart-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfofromCart</code></a></li><li><a href="#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a></li><li><a href="#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWCSepPV</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWCSepPV</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a></li><li><a href="#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.RCSPlot</code></a></li><li><a href="#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}"><code>MoM_Kernels.ZnearChunkMulIVec!</code></a></li><li><a href="#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2Level2!</code></a></li><li><a href="#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.adjoint_aggOnBF!</code></a></li><li><a href="#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2LeafLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.adjoint_disaggOnBF!</code></a></li><li><a href="#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}"><code>MoM_Kernels.adjoint_transOnLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_transOnLevels!</code></a></li><li><a href="#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.agg2Level2!</code></a></li><li><a href="#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.aggOnBF!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.aggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelCFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelCFIE!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelEFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelEFIE!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelMFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelMFIE!</code></a></li><li><a href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a></li><li><a href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a></li><li><a href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a></li><li><a href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a></li><li><a href="#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLMFAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.calZfarI!</code></a></li><li><a href="#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}"><code>MoM_Kernels.calZnearCSC</code></a></li><li><a href="#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}"><code>MoM_Kernels.calZnearCSC!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCCFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIEnew!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCMFIE!</code></a></li><li><a href="#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLMFAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.caladjZfarI!</code></a></li><li><a href="#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}"><code>MoM_Kernels.calαTransOnLevel!</code></a></li><li><a href="#MoM_Kernels.coeffgreen-Tuple{Integer}"><code>MoM_Kernels.coeffgreen</code></a></li><li><a href="#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Kernels.convergencePlot</code></a></li><li><a href="#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>MoM_Kernels.cooraInCoorb</code></a></li><li><a href="#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2LeafLevel!</code></a></li><li><a href="#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.disaggOnBF!</code></a></li><li><a href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a></li><li><a href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorCFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorMFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE!</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}"><code>MoM_Kernels.faceSingularityIgIvecg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIgIvecgI∇gS</code></a></li><li><a href="#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIᵣIᵨ</code></a></li><li><a href="#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.farEPlot</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Tuple{Any, Any, Any}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}"><code>MoM_Kernels.func4Cube1stkInterval</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getBfsCenter</code></a></li><li><a href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType"><code>MoM_Kernels.getBfsCenter</code></a></li><li><a href="#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}"><code>MoM_Kernels.getCubeIDsWithGeos</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}"><code>MoM_Kernels.getGeoIDsInCubeChunk</code></a></li><li><a href="#MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getGeosInterval</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType"><code>MoM_Kernels.getImpedanceMatrix</code></a></li><li><a href="#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}"><code>MoM_Kernels.getImpedanceOpt</code></a></li><li><a href="#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}"><code>MoM_Kernels.getImpedanceOptAndExciteVOctree</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}"><code>MoM_Kernels.getMeshDataSaveGeosInterval</code></a></li><li><a href="#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeiFarNeighborCubeIDs</code></a></li><li><a href="#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeighborCubeIDs</code></a></li><li><a href="#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}"><code>MoM_Kernels.getOctreeAndReOrderBFs!</code></a></li><li><a href="#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}"><code>MoM_Kernels.get_Interpolation_Method</code></a></li><li><a href="#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}"><code>MoM_Kernels.get_chunks_minmax_col</code></a></li><li><a href="#MoM_Kernels.get_leafCubeSize-Tuple{}"><code>MoM_Kernels.get_leafCubeSize</code></a></li><li><a href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>MoM_Kernels.get_partition</code></a></li><li><a href="#MoM_Kernels.get_partition_map-Tuple{Any, Any}"><code>MoM_Kernels.get_partition_map</code></a></li><li><a href="#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}"><code>MoM_Kernels.gq_xsws_on_sphere</code></a></li><li><a href="#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat"><code>MoM_Kernels.greenfunc_star</code></a></li><li><a href="#MoM_Kernels.iluPrecondition-Tuple{Any, Any}"><code>MoM_Kernels.iluPrecondition</code></a></li><li><a href="#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4CFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4MFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGRBF!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGSWG!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGPWC</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGRBF</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGSWG</code></a></li><li><a href="#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialVMulZchunks!</code></a></li><li><a href="#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialZchunksMulV!</code></a></li><li><a href="#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSC</code></a></li><li><a href="#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSR</code></a></li><li><a href="#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}"><code>MoM_Kernels.initialZnearChunks</code></a></li><li><a href="#MoM_Kernels.inputParameters-Tuple{}"><code>MoM_Kernels.inputParameters</code></a></li><li><a href="#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.integral1DXW</code></a></li><li><a href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a></li><li><a href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a></li><li><a href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a></li><li><a href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a></li><li><a href="#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.interpolationCSCMatCal</code></a></li><li><a href="#MoM_Kernels.iterSolverSet-Tuple{Symbol}"><code>MoM_Kernels.iterSolverSet</code></a></li><li><a href="#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real"><code>MoM_Kernels.levelIntegralInfoCal</code></a></li><li><a href="#MoM_Kernels.loadCurrent-Tuple{Any}"><code>MoM_Kernels.loadCurrent</code></a></li><li><a href="#MoM_Kernels.loadGeoInterval-Tuple{Any}"><code>MoM_Kernels.loadGeoInterval</code></a></li><li><a href="#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.memoryAllocationOnLevels!</code></a></li><li><a href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>MoM_Kernels.modiSingularityRelatedConsts!</code></a></li><li><a href="#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.octreeXWNCal</code></a></li><li><a href="#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickCycleVec</code></a></li><li><a href="#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickθ</code></a></li><li><a href="#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real"><code>MoM_Kernels.pickϕ</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.reOrderCubeID!</code></a></li><li><a href="#MoM_Kernels.record_memorys-Tuple{Any}"><code>MoM_Kernels.record_memorys</code></a></li><li><a href="#MoM_Kernels.restore_infos-Tuple{}"><code>MoM_Kernels.restore_infos</code></a></li><li><a href="#MoM_Kernels.saveCubes-Tuple{Any, Any}"><code>MoM_Kernels.saveCubes</code></a></li><li><a href="#MoM_Kernels.saveCurrent-Tuple{Any}"><code>MoM_Kernels.saveCurrent</code></a></li><li><a href="#MoM_Kernels.saveGeoInterval-Tuple{Any}"><code>MoM_Kernels.saveGeoInterval</code></a></li><li><a href="#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}"><code>MoM_Kernels.saveGeosInfoChunks</code></a></li><li><a href="#MoM_Kernels.saveLevel"><code>MoM_Kernels.saveLevel</code></a></li><li><a href="#MoM_Kernels.saveOctree-Tuple{Any}"><code>MoM_Kernels.saveOctree</code></a></li><li><a href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}"><code>MoM_Kernels.saveVec2Chunks</code></a></li><li><a href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}"><code>MoM_Kernels.saveVec2Chunks</code></a></li><li><a href="#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer"><code>MoM_Kernels.searchNearCubes</code></a></li><li><a href="#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setBFInterval!</code></a></li><li><a href="#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real"><code>MoM_Kernels.setBigCube</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}"><code>MoM_Kernels.setKidLevelFarNeighbors!</code></a></li><li><a href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a></li><li><a href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a></li><li><a href="#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelTransFactor!</code></a></li><li><a href="#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsCubesKidsIn8!</code></a></li><li><a href="#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsShiftFactor!</code></a></li><li><a href="#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}"><code>MoM_Kernels.setVSC₁₂₃ⁿ!</code></a></li><li><a href="#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}"><code>MoM_Kernels.set_Interpolation_Method!</code></a></li><li><a href="#MoM_Kernels.set_geosInterval!-Tuple{Any}"><code>MoM_Kernels.set_geosInterval!</code></a></li><li><a href="#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.set_leafCubeSize!</code></a></li><li><a href="#MoM_Kernels.set_nprocs!-Tuple{}"><code>MoM_Kernels.set_nprocs!</code></a></li><li><a href="#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a></li><li><a href="#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a></li><li><a href="#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF21</code></a></li><li><a href="#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF22</code></a></li><li><a href="#MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2cuts</code></a></li><li><a href="#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2idxs</code></a></li><li><a href="#MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}"><code>MoM_Kernels.sizeChunksCuts2indices</code></a></li><li><a href="#MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}"><code>MoM_Kernels.slicedim2bounds</code></a></li><li><a href="#MoM_Kernels.slicedim2partition-Tuple{Any, Int64}"><code>MoM_Kernels.slicedim2partition</code></a></li><li><a href="#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve</code></a></li><li><a href="#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve!</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h1l</code></a></li><li><a href="#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l</code></a></li><li><a href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h1l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h2l</code></a></li><li><a href="#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l</code></a></li><li><a href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h2l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l_array</code></a></li><li><a href="#MoM_Kernels.transOnLevel!-Tuple{Any}"><code>MoM_Kernels.transOnLevel!</code></a></li><li><a href="#MoM_Kernels.transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.transOnLevels!</code></a></li><li><a href="#MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real"><code>MoM_Kernels.truncationLCal</code></a></li><li><a href="#MoM_Kernels.truncationLCal-Tuple{}"><code>MoM_Kernels.truncationLCal</code></a></li><li><a href="#MoM_Kernels.use_CSR-Tuple{}"><code>MoM_Kernels.use_CSR</code></a></li><li><a href="#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIg</code></a></li><li><a href="#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIgIvecg</code></a></li><li><a href="#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityLOpDyad</code></a></li><li><a href="#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}"><code>MoM_Kernels.writeZtt!</code></a></li><li><a href="#MoM_Basics.@clock-Tuple{Any, Any}"><code>MoM_Basics.@clock</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.GeosInterval" href="#MoM_Kernels.GeosInterval"><code>MoM_Kernels.GeosInterval</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>保存网格数据区间的实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MLFMAParams" href="#MoM_Kernels.MLFMAParams"><code>MoM_Kernels.MLFMAParams</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>多层快速多极子的可调参数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.ParallelParams" href="#MoM_Kernels.ParallelParams"><code>MoM_Kernels.ParallelParams</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>保存并行参数的实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.SSCg" href="#MoM_Kernels.SSCg"><code>MoM_Kernels.SSCg</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>计算面奇异性时用的两个系数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.SSCgdivnp2" href="#MoM_Kernels.SSCgdivnp2"><code>MoM_Kernels.SSCgdivnp2</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>计算体奇异性时用到的一些系数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.VSC₃ⁿ" href="#MoM_Kernels.VSC₃ⁿ"><code>MoM_Kernels.VSC₃ⁿ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>这一项面、体奇异性都用到了，处理对格林函数梯度求积时的奇异性时用到的。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.ZnearT" href="#MoM_Kernels.ZnearT"><code>MoM_Kernels.ZnearT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>近场阻抗矩阵的类型集合。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.CubeInfo" href="#MoM_Kernels.CubeInfo"><code>MoM_Kernels.CubeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CubeInfo{IT&lt;:Integer, FT&lt;:Real}</code></pre><p>盒子信息，包括：</p><pre><code class="nohighlight hljs">kidsInterval    ::UnitRange{IT}     子层盒子id的区间
bfInterval      ::UnitRange{IT}     包含的基函数区间
kidsIn8         ::Vector{IT}        非空子盒子在8个子盒子中的id
geoIDs          ::Vector{IT}        包含的网格如三角形、四面体的id，以基函数进行分，因此边界上的同一个网格可能被分到不同的盒子内。
neighbors       ::Vector{IT}        邻盒子id
farneighbors    ::Vector{IT}        远亲盒子的id
ID3D            ::MVec3D{IT}        本盒子在本层的三维整数坐标
center          ::MVec3D{FT}        本盒子在本层的三维全局坐标</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.GLPolesInfo" href="#MoM_Kernels.GLPolesInfo"><code>MoM_Kernels.GLPolesInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>多极子的极信息，即角谱空间采样信息 Xθs::Vector{FT}，θ方向的采样点坐标（rad单位），高斯-勒让德求积 Xϕs::Vector{FT}，ϕ方向的采样点坐标（rad单位），均值求积 Wθϕs::Vector{FT}，采样点权重，用于积分时使用，在MLFMA中直接乘在转移项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.GeosIntervalType" href="#MoM_Kernels.GeosIntervalType"><code>MoM_Kernels.GeosIntervalType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeosIntervalType{T}</code></pre><p>保存网格数据区间的类。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.LagrangeInterp1StepInfo" href="#MoM_Kernels.LagrangeInterp1StepInfo"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存总的 稀疏插值矩阵，用于单步插值，根据稀疏度决定保存稀疏阵或是稠密阵 θϕCSC       ::AbstractMatrix{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 θϕCSCT      ::AbstractMatrix{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}" href="#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>带参数的构造函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.LagrangeInterpInfo" href="#MoM_Kernels.LagrangeInterpInfo"><code>MoM_Kernels.LagrangeInterpInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存 θ, ϕ 两个方向的稀疏插值矩阵， θ方向为 (npXθs, ntXθs) 稀疏矩阵, 用于左乘本层多极子矩阵，在 θ 方向插值 ϕ方向为 (ntXϕs, ntXϕs) 稀疏矩阵, 用于右乘本层多极子矩阵，在 ϕ 方向插值 θCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 ϕCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}" href="#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterpInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>带参数的构造函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.LevelInfo" href="#MoM_Kernels.LevelInfo"><code>MoM_Kernels.LevelInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LevelInfo{IT&lt;:Integer, FT&lt;:Real, IPT} &lt;: AbstractLevel</code></pre><p>层信息：</p><pre><code class="nohighlight hljs">ID          ::IT                        层序号
isleaf      ::Bool                      是否为叶层
L           ::IT                        本层截断项数
cubes       ::Vector{CubeInfo{IT, FT}}  包含每一个盒子信息的向量
cubeEdgel   ::FT                        本层盒子的边长
poles       ::PolesInfo{IT, FT}         多极子采样信息
interpWθϕ   ::InterpInfo{IT, FT}        插值信息
aggS        ::Array{Complex{FT}, 3}     聚合项
disaggG     ::Array{Complex{FT}, 3}     解聚项
phaseShift2Kids  ::Array{Complex{FT}, 3}本层盒子到子层盒子的相移因子 
αTrans      ::Array{Complex{FT}, 3}     本层盒子远亲组之间的转移因子，根据相对位置共有 7^3 - 3^3 = 316 个
αTransIndex ::Array{IT, 2}              远亲盒子的相对位置到其转移因子在所有转移因子数组的索引</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MLFMAParamsType" href="#MoM_Kernels.MLFMAParamsType"><code>MoM_Kernels.MLFMAParamsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建可变参数类型以在频率更改时对应更改 MLFMA 的相关参数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MLMFAIterator" href="#MoM_Kernels.MLMFAIterator"><code>MoM_Kernels.MLMFAIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存 MLFMA 相关信息的结构体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MLMFAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}" href="#MoM_Kernels.MLMFAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.MLMFAIterator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现矩阵向量乘积，并封装为线性算子</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MatrixChunk" href="#MoM_Kernels.MatrixChunk"><code>MoM_Kernels.MatrixChunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixChunk{T&lt;:Number} &lt;:AbstractMatrix{T}</code></pre><p>创建近场矩阵块结构体，所包含的数据为某一盒子内的近场矩阵元。</p><pre><code class="nohighlight hljs">m::Int                          行数
n::Int                          列数
mat::Matrix{T}                  矩阵
rowIndices::AbstractVector{Int} 行索引
colIndices::AbstractVector{Int} 列索引
lmul::AbstractVector{T}         用于左乘其它矩阵、向量的临时数组，大小与列数相同
rmul::AbstractVector{T}         用于右乘其它矩阵、向量的临时数组，大小与行数相同</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number" href="#MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number"><code>MoM_Kernels.MatrixChunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MatrixChunk{T}(rowIndices, colIndices) where {T&lt;:Number}</code></pre><p>用行、列索引 <code>rowIndices, colIndices</code> 初始化矩阵块。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.OctreeInfo" href="#MoM_Kernels.OctreeInfo"><code>MoM_Kernels.OctreeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>八叉树类 nLevels ::Integer, 叶层ID（定义大盒子为（“0” 层），叶层为第“n”层，nLevels取“n”的值） leafCubeEdgel::FT，叶层盒子边长 bigCubeLowerCoor::MVec3D{FT}，第0层盒子的角坐标 levels  ::Dict{Int, LevelInfo}，保存各层信息的字典</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.OctreeInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>构建八叉树类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.PartitionedVector" href="#MoM_Kernels.PartitionedVector"><code>MoM_Kernels.PartitionedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionedVector{T} &lt;: AbstractVector{T}</code></pre><p>用于保存向量块的类，同时在块内保存一些其他块的数据。</p><pre><code class="nohighlight hljs">size::Int                           原始 Vector 的大小
data::OffsetVector{T, Vector{T}}    本地保存的数据
indices::UnitRange{Int}             本地保存数据的索引区间
ghostdata::SparseVector{T, Int}     用到的其它数据
ghostindices::Vector{Int}           用到的其它数据的索引区间</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.SAIChunkPrec" href="#MoM_Kernels.SAIChunkPrec"><code>MoM_Kernels.SAIChunkPrec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SAIChunkPrec{T} &lt;: AbstractMatrix{T}</code></pre><p>分块系数近似逆的结构体。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.SAIPrec" href="#MoM_Kernels.SAIPrec"><code>MoM_Kernels.SAIPrec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SAIPrec{T} &lt;: AbstractMatrix{T}</code></pre><p>封装系数近似逆矩阵的类型。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.ZnearChunksStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建近场矩阵结构体，所包含的数据为所有盒子内的近场矩阵元，多线程版本</p><pre><code class="nohighlight hljs">m::Int，行数
n::Int，列数
nChunks::Int，矩阵块儿数
chunks::Vector{ZnearChunksStruct{T}}，矩阵
lmul::Vector{T}，用于左乘其它矩阵、向量的临时数组，大小与列数相同
lmuld::Vector{T}，用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配
rmul::Vector{T}，用于右乘其它矩阵、向量的临时数组，大小与行数相同
lmuld::Vector{T}，用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number" href="#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number"><code>MoM_Kernels.ZnearChunksStruct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ZnearChunksStruct 类的初始化函数，将 lumld 和 rmuld 初始化为</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(mat::AbstractMatrix, Z::T) where{T&lt;:MatrixChunk}</code></pre><p>实现右乘其它矩阵，默认矩阵块较小，不在本阶段并行。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractVector, Z::T) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 右乘其它向量，默认矩阵块较小，不在本阶段并行。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number" href="#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现左乘其它矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(Z::T, mat::AbstractMatrix) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 左乘其它矩阵，默认矩阵块较小，不在本阶段并行。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(Z::T, x::AbstractVector) where{T&lt;:MatrixChunk}</code></pre><p>实现左乘其它向量，默认矩阵块较小，因此不在本阶段并行</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现左乘其它向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}" href="#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现包含分布式层的</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{IncompleteLU.ILUFactorization}" href="#Base.eltype-Tuple{IncompleteLU.ILUFactorization}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(opt::ILUFactorization)</code></pre><p>提供 ilu 的算子 eltype 函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer" href="#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(A::PartitionedVector, i::I) where {I&lt;:Integer}</code></pre><p>重载 <code>PartitionedVector</code> 类型的 <code>getindex</code> 函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(Z::T, i1::Int, i2::Int) where{T&lt;:MatrixChunk}</code></pre><p>重载 getindex 函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>重载 getindex 函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(Z::T, x, i1::Int, i2::Int) where{T&lt;:MatrixChunk}</code></pre><p>重载 setindex! 函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK" href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>重载 setindex! 函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization" href="#Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(operator::T) where {T&lt;:ILUFactorization}</code></pre><p>提供 ilu 的算子 size 函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T" href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldiv!(M::SAIChunkPrec{T}, x::AbstractVector) where {T}
ldiv!(y::AbstractVector, M::SAIChunkPrec{T}, x::AbstractVector) where {T}</code></pre><p>实现 <code>x .= M * x</code> 或 <code>y .= M * x</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T" href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldiv!(M::SAIPrec{T}, x::AbstractVector) where {T}
ldiv!(y::AbstractVector, M::SAIPrec{T}, x::AbstractVector) where {T}</code></pre><p>实现 <code>x .= M * x</code> 或 <code>y .= M * x</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{AbstractVector, MLMFAIterator, AbstractVector, Number, Number}" href="#LinearAlgebra.mul!-Tuple{AbstractVector, MLMFAIterator, AbstractVector, Number, Number}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any, MLMFAIterator, Any}" href="#LinearAlgebra.mul!-Tuple{Any, MLMFAIterator, Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(y, Z::T, x::AbstractVector) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 的矩阵向量乘积计算。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}" href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, Any}} where {T, V}" href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, Any}} where {T, V}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWCSepPV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入 hexat     :   HexahedraInfo, 场六面体和源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat::HexahedraInfo,   场六面体 tetras::TetrahedraInfo  源四面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合但相隔较近的情况，输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, TetrahedraInfo, 源四面体、四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合但相隔较近的情况，输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, 源四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 18 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 hexas   ::  HexahedraInfo, 源六面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWCSepPV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，函数将主值积分分开返回以便它用</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real" href="#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.RCSPlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RCS 绘图</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}" href="#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}"><code>MoM_Kernels.ZnearChunkMulIVec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZnearChunkMulIVec!(ZnearChunk, resultChunk, IVec)</code></pre><p>计算某一块的矩阵向量乘积</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2Level2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从叶层聚合到第 &#39;2&#39; 层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number" href="#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.adjoint_aggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层从基函数向盒子聚合</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2LeafLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>解聚到叶层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}" href="#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.adjoint_disaggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层往测试基函数解聚</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}" href="#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}"><code>MoM_Kernels.adjoint_transOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>层内转移</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_transOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>各层内转移</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}" href="#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}" href="#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.agg2Level2!-Tuple{Any, Any}" href="#MoM_Kernels.agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.agg2Level2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从叶层聚合到第 &#39;2&#39; 层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number" href="#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.aggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层从基函数向盒子聚合</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}</code></pre><p>计算某层采用 EFIE 时在六面体上的 PWC 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}</code></pre><p>计算某层采用 EFIE 时在四面体上的 PWC 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}</code></pre><p>计算某层采用 EFIE 时 SWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{VT}, 
::Type{BFT}; setzero = true) where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}</code></pre><p>计算某层采用 EFIE 时在六面体上的 RBF 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.aggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel(level::LT, geosInfo::AbstractVector{VT}, 
bfsInfo::AbstractVector{BFT}) where {LT&lt;:LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}</code></pre><p>计算某层采用 EFIE 时 SWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelCFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 CFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelCFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 CFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code> ,  输入为层信息 <code>level</code> 、三角形信息 <code>trianglesInfo</code> 和基函数信息 <code>bfsInfo</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelEFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 EFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelEFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 EFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code> ,  输入为层信息 <code>level</code> 、三角形信息 <code>trianglesInfo</code> 和基函数信息 <code>bfsInfo</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelMFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelMFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo::Vector{RWG{IT, FT}}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步反插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLMFAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}" href="#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLMFAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.calZfarI!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算远区矩阵向量乘积</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}" href="#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}"><code>MoM_Kernels.calZnearCSC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, 
    Znear, bfT::Type{BFT} = VSBFTypes.sbfType) where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}
calZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, 
    Znear, bfT::Type{BFT} = VSBFTypes.vbfType) where {BFT&lt;:BasisFunctionType, VSCellT&lt;:VolumeCellType}
calZnearCSC!(level, geosInfo::AbstractVector{VT}, 
    Znear) where {VT&lt;:AbstractVector}</code></pre><p>根据八叉树层信息 <code>level</code> 和几何信息 <code>geosInfo</code> 、基函数信息 <code>bfsInfo</code> 计算近场阻抗矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}" href="#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}"><code>MoM_Kernels.calZnearCSC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSC(level, geosInfo::Vector, bfsInfo::Vector)</code></pre><p>根据八叉树层信息 <code>level</code> 和几何信息 <code>geosInfo</code> 、基函数信息 <code>bfsInfo</code> 计算近场阻抗矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSCCFIE!(level, trianglesInfo::Vector{TriangleInfo{IT, FT}},
    Znear::ZnearT{CT}, ::Type{BFT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}</code></pre><p>采用 RWG 基函数计算 CFIE 面积分（SIE）阻抗矩阵近场元并将结果放在 ZnearCSC 稀疏矩阵中。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数计算四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 SWG 基函数计算网格元 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + SWG 基函数计算 三角形 + 四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG 基函数计算 EFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC + PWC 基函数计算 四面体 + 六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + PWC 基函数计算 三角形 + 四面体/六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIEnew!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG 基函数计算 MFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLMFAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}" href="#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLMFAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.caladjZfarI!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算远区矩阵的伴随矩阵向量乘积</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}" href="#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}"><code>MoM_Kernels.calαTransOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算 level 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.coeffgreen-Tuple{Integer}" href="#MoM_Kernels.coeffgreen-Tuple{Integer}"><code>MoM_Kernels.coeffgreen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coeffgreen(n::Integer)</code></pre><p>归一化格林函数 (不包括<span>$\frac{1}{4π}$</span>项) 的展开系数函数，从 0 阶 到 n 阶：</p><p class="math-container">\[\begin{aligned}
g(R)    &amp;= \frac{e^{-jkR}}{R} = \sum_{n=0}^{SglrOrder}coeffgreen(n)R^{n-1}\\
coeffgreen(n)  &amp;=   \frac{{-jk}^{n}}{n!}\\
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Kernels.convergencePlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算完成后绘制收敛曲线</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>MoM_Kernels.cooraInCoorb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算一维坐标coora在坐标corrb中的位置</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}" href="#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}" href="#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}" href="#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2LeafLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>解聚到叶层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}" href="#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.disaggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层往测试基函数解聚</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算给定三角形面片位置 r 处的电流 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： r               ::Vec3D{FT} ICoeff          ::Vec3D{CT}  三角形上的三个基函数的计算得到的电流系数 triangleInfo    ::TriangleInfo{IT, FT}，三角形信息 输出值: Jtrir           ::Complex{FT}, 三角形上加权后的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算所有三角形上的高斯求积点电流权重乘积 JₙᵢWᵢ 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 JₙᵢWᵢ = ∑ₜₙ₌₁³ Iₜₙlₜₙ/2Sₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定六面体的六个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的四个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, tris::TriangleInfo{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算场点<code>rgt</code>在源三角形<code>tris</code>上的奇异性，<code>tris</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, tris::Tris4Tetra{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算场点<code>rgt</code>在源三角形<code>tris</code>（该三角形为组成四面体的某一面）上的奇异性，<code>tris</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, polys::ST, area::FT, 
facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}</code></pre><p>计算场点<code>rgt</code>在多边形<code>polys</code>上的奇异性，<code>polys</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}" href="#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}"><code>MoM_Kernels.faceSingularityIgIvecg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIgIvecg(rgt::AbstractVector{FT}, polys::ST, area, 
    facen̂::AbstractVector) where {FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}</code></pre><p>计算场点<code>rgt</code>在多边形<code>polys</code>上的奇异性，<code>polys</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
\boldsymbol{I}_{gS}  &amp;= \int{\boldsymbol{R}g(R)dS&#39;}\\
        &amp;= \sum_{l_j}{\hat{\bm{u}}_j \sum_{n=0}^{SglrOrder}{\frac{coeffgreen(n)}{n+1}I^{n-1}_{lr}}} + d\bm{n}I^{n-1}_{gS}\\
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}" href="#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIgIvecgI∇gS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>面上的近奇异性 rgt, 为场三角形的求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: IgS     =   ∫ g(R) dS&#39;      =   ∑ₙ₌₀(coeffgreen(n)<em>IR[n-1]) IvecgS  =   ∫ Rvec g(R) dS&#39; =   ∑ₗⱼ ûⱼ ∑ₙ₌₀(coeffgreen(n)/(n+1)</em>Ilᵣ[n-1]) + dn̂IgS I∇gS    =   ∫ ∇g(R) dS&#39;     =   ∑ₙ₌₀VSC₃ⁿ*(-1/(n+2)∑ₗⱼûⱼIlᵣ[n+2] + dn̂IgS )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIᵣIᵨ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>面上的近奇异性 rgts::MMatrix{GQPNTriSglr, 3, Complex{FT}}, 为场三角形的所有高斯求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: r0tProj2s::MMatrix{3, GQPNTriSglr, Complex{FT}, 3GQPNTriSglr}, 积分点在源三角形上的投影点 Iᵣ  =   ∫ 1/R dS&#39;   =   ∑₁³(p02il<em>fᵢ - dtsAbs</em>βᵢ) Iᵨ  =   ∫ ρ/R dS&#39;   =   0.5∑₁³{ûᵢ[(R0^2<em>fᵢ + li⁺</em>R⁺ - li⁻*R⁻)]}</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real" href="#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.farEPlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>farE 绘图</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.farField-Tuple{Any, Any, Any}" href="#MoM_Kernels.farField-Tuple{Any, Any, Any}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}" href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}" href="#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}"><code>MoM_Kernels.func4Cube1stkInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">func4Cube1stkInterval(cube::CubeInfo)
func4Cube1stkInterval(i::T) where T
func4Cube1stkInterval(interval::T) where T &lt;: UnitRange
func4CubelastkInterval(cube::CubeInfo)
func4CubelastkInterval(i::T) where T
func4CubelastkInterval(interval::T) where T</code></pre><p>这六个函数用于寻找盒子的子盒子区间内的比较函数，多重分派以实现不同数据类型的比较。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上的电流。 分片常数基 RBF 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 6 或 3 个基函数，因此 Jₜ = ∑ₜₙ₌₁ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上加权后的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上的电流。 分片常数基 SWG 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在四个基函数，因此 Jₜ = ∑ₜₙ₌₁⁴ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上加权后的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形面片上的加权电流。 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType" href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType"><code>MoM_Kernels.getBfsCenter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算基函数中心的数组，用于方便混合基函数使用时的情况</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getBfsCenter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算基函数中心的数组，用于方便混合基函数使用时的情况</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}" href="#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}"><code>MoM_Kernels.getCubeIDsWithGeos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>找到 geosInfo 所在的所有 cude id</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}" href="#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}"><code>MoM_Kernels.getGeoIDsInCubeChunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGeoIDsInCubeChunk(cubes, chunkIndice::Tuple)
getGeoIDsInCubeChunk(cubes, ckunkIndice::UnitRange)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的编号， 返回为 Tuple 形式以适应数组索引相关API</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)" href="#MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getGeosInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGeosInterval(geosInfo::T) where {T&lt;:AbstractVector}
getGeosInterval(geosInfo::T) where {T&lt;:OffsetVector}</code></pre><p>获取几何信息数组的区间，针对普通 <code>Vector</code> 和 <code>OffsetVector</code> 分别派发。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}" href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}" href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 bfsInfo::   基函数信息 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType" href="#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType"><code>MoM_Kernels.getImpedanceMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 返回： Zmat</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}" href="#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}"><code>MoM_Kernels.getImpedanceOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵算子 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}" href="#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}"><code>MoM_Kernels.getImpedanceOptAndExciteVOctree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵算子和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>六面体从网格平均尺寸设置整体的叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>四面体从网格平均尺寸设置整体的叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>三角形面网格直接设置为的叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>混合网格从第2类里的网格平均尺寸设置整体的叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}" href="#MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}"><code>MoM_Kernels.getMeshDataSaveGeosInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMeshDataSaveGeosInterval(filename[; meshUnit=:mm, dir = &quot;temp/GeosInfo&quot;])</code></pre><p>在获取网格数据 <code>meshData</code> 和介电参数 <code>εᵣs</code> 的同时保存网格数据 <code>meshData</code> 中各类型网格的区间。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}" href="#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeiFarNeighborCubeIDs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNeiFarNeighborCubeIDs(cubes, chunkIndice::Tuple)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的 远亲盒子 序号， 返回为 <code>Tuple</code> 形式以适应数组索引相关 API。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}" href="#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeighborCubeIDs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNeighborCubeIDs(cubes, chunkIndice::Tuple)
getNeighborCubeIDs(cubes, chunkIndice::AbstractVector)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的 <code>邻盒子</code> 编号， 返回为 <code>Tuple</code> 形式以适应数组索引相关API</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}" href="#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}"><code>MoM_Kernels.getOctreeAndReOrderBFs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据基函数中心位置构建八叉树，并重排基函数信息、将新基函数 ID 赋值给几何元信息数组 返回值： nLevels::   层数 octree::    得到的八叉树 leafCubeEdgel:: 控制叶层盒子大小 isDistribute:: 控制是否为分布式计算</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}" href="#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}"><code>MoM_Kernels.get_Interpolation_Method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Interpolation_Method(method::Symbol)
get_Interpolation_Method(method::Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}})</code></pre><p>获取插值算法。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.get_chunks_minmax_col-Tuple{Any}" href="#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}"><code>MoM_Kernels.get_chunks_minmax_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_chunks_minmax_col(matchunks)</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.get_leafCubeSize-Tuple{}" href="#MoM_Kernels.get_leafCubeSize-Tuple{}"><code>MoM_Kernels.get_leafCubeSize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>获取叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.get_partition-Tuple{Any, Any, Any}" href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>MoM_Kernels.get_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_partition(nCubes, sizePoles, np)</code></pre><p>根据给定的盒子数 <code>nCubes</code> 、多极子数 <code>sizePoles</code>、进程数 <code>np</code> 返回该层辐射函数的三个维度的划分数量。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.get_partition_map-Tuple{Any, Any}" href="#MoM_Kernels.get_partition_map-Tuple{Any, Any}"><code>MoM_Kernels.get_partition_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_partition_map(partition, kcubeIndices)</code></pre><p>根据 <code>partition</code> 计算在盒子方向本层所有 rank 到子层所有 rank 的 map 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}" href="#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}"><code>MoM_Kernels.gq_xsws_on_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gq_xsws_on_sphere(L)

计算单位球面 2(L+1) 阶高斯求积的采样点坐标权重</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat" href="#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat"><code>MoM_Kernels.greenfunc_star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greenfunc_star(pa::Vec3D{T}, pb::Vec3D{T}[; k=Params.K_0, taylorOrder = SglrOrder]) where {T&lt;:AbstractFloat}</code></pre><p>归一化格林函数 <span>$4πG(R)$</span> 泰勒展开后去奇异项：</p><p class="math-container">\[g^{*}(R)    = \frac{e^{-jkR}}{R} - \frac{1}{R}
            = \sum_{n=1}^{SglrOrder}\frac{{-jk}^{n}}{n!}R^{n-1}.\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.iluPrecondition-Tuple{Any, Any}" href="#MoM_Kernels.iluPrecondition-Tuple{Any, Any}"><code>MoM_Kernels.iluPrecondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iluPrecondition(A, level; τ = 1e-3)</code></pre><p>从 (IncompleteLU.jl)[https://github.com/haampie/IncompleteLU.jl.git]  包实现ilu, 再次封装是因为要加入一些判断</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4CFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的CFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于在有矩阵的情况下计算PEC的EFIE阻抗矩阵。 输入信息： Zmat trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的EFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4MFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的MFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + PWC 部分的阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + PWC 部分的阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGRBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + RBF 部分的阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGSWG!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + SWG 部分的阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的 EFIE 阻抗矩阵。 输入信息： Zmat       :   已初始化的阻抗矩阵 tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算混合网格（四面体+六面体）下介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： geosInfo    :  为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算VSIE的矩阵</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialVMulZchunks!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>初始化 阻抗矩阵 右乘 向量 乘积的 分布式数组</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialZchunksMulV!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>初始化 阻抗矩阵 左乘 向量 乘积的 分布式数组</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}" href="#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearCSC(level, nbf::Int)</code></pre><p>根据八叉树层信息 <code>level</code> 初始化近场阻抗矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}" href="#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearCSR(level, nbf::Int)</code></pre><p>根据八叉树层信息 <code>level</code> 初始化近场阻抗矩阵，用 <code>transpose</code> 实现 CSR 压缩稀疏行。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}" href="#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}"><code>MoM_Kernels.initialZnearChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearChunks(cube, cubes::AbstractVector; CT = Complex{Precision.FT})</code></pre><p>根据八叉树某个盒子 <code>cube</code> 信息初始化 <code>cube</code> 对应的近场矩阵元块。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.inputParameters-Tuple{}" href="#MoM_Kernels.inputParameters-Tuple{}"><code>MoM_Kernels.inputParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputParameters(;args...)</code></pre><p>用于输入仿真参数，并修改奇异性处理中频率相关常量。 详见 <a href="#MoM_Basics.inputBasicParameters-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.inputBasicParameters</code></a> 和 <a href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>modiSingularityRelatedConsts!</code></a>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.integral1DXW</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算分别采用高斯求积、中点求积计算 θ,ϕ 方向的采样点的坐标、权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 Nsample::IT, 采样点数 mod::Symbol， 模式，接受 :uni, 均值积分 :glq, 高斯-勒让德积分 两种模式</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步插值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.interpolationCSCMatCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用局部插值、两步插值法，计算局部坐标到全局坐标的稀疏插值矩阵，Julia数据存储为列主的，因此使用 压缩稀疏列(Compressed Sparse Column, CSC) pLevelPoles::GLPolesInfo{FT}， 父层多极子信息 tLevelPoles::GLPolesInfo{FT}， 本层多极子信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.iterSolverSet-Tuple{Symbol}" href="#MoM_Kernels.iterSolverSet-Tuple{Symbol}"><code>MoM_Kernels.iterSolverSet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>迭代求解器选择</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real" href="#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real"><code>MoM_Kernels.levelIntegralInfoCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算八叉树的积分相关信息，包括截断项、各层积分点和求积权重数据 输入: levelCubeEdgel::FT,  层盒子边长, 一般叶层为0.25λ，其中 λ 为区域局部波长。 返回值 L           ::IT， 层 截断项 levelsPoles ::Vector{GLPolesInfo{FT}}，从叶层到第 “2” 层的角谱空间采样信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.loadCurrent-Tuple{Any}" href="#MoM_Kernels.loadCurrent-Tuple{Any}"><code>MoM_Kernels.loadCurrent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>读取电流系数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.loadGeoInterval-Tuple{Any}" href="#MoM_Kernels.loadGeoInterval-Tuple{Any}"><code>MoM_Kernels.loadGeoInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_geosInterval!(fn)</code></pre><p>载入文件 <code>fn</code> 读取网格数据区间。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}" href="#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.memoryAllocationOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>预分配各层上的聚合项、解聚项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}" href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>MoM_Kernels.modiSingularityRelatedConsts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于输入参数（特指频率）改变时的更改相关常数项</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.octreeXWNCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算各层八叉树求积坐标、求积权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 nlevels::IT, 八叉树叶层ID mod::Symbol， 模式，接受 :uni, 均值积分(ϕ方向) :glq, 高斯-勒让德积分(θ方向) 两种模式</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real" href="#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickCycleVec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据循环向量 cycleVec 的周期性索引超出上下界的 index 对应的值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real" href="#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickθ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>利用 θ 在极点附近的对称性计算索引超出上下界的 θ 值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real" href="#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real"><code>MoM_Kernels.pickϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>利用 ϕ 的周期性索引超出上下界的 ϕ 值</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在设定好的观测角度上的球坐标处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用 RBF 基函数时，六面体上没有统一的电流值 N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用 SWG 基函数时，四面体上没有统一的电流值，每一点上都是四面电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁⁴ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dV)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁⁴ IₙSₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁⁴ IₙSₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息，此函数适用于 PWC 基函数的情况</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.reOrderCubeID!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据排序后的新id重新排列子层盒子以及盒子的邻盒子信息，以将同一个父盒子层的盒子相邻排列，这样有利于计算 更新的量：父层盒子的kidsInterval， 本层的盒子顺序，本层盒子的邻盒子id</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.record_memorys-Tuple{Any}" href="#MoM_Kernels.record_memorys-Tuple{Any}"><code>MoM_Kernels.record_memorys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>展示</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.restore_infos-Tuple{}" href="#MoM_Kernels.restore_infos-Tuple{}"><code>MoM_Kernels.restore_infos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restore_infos()
记录各部分内存和各阶段计算时间。</code></pre><p>TBW</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveCubes-Tuple{Any, Any}" href="#MoM_Kernels.saveCubes-Tuple{Any, Any}"><code>MoM_Kernels.saveCubes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveCubes(cubes[, nchunk = ParallelParams.nprocs; name, dir=&quot;&quot;, kcubeIndices = nothing])</code></pre><p>将盒子 <code>cubes</code> 分为 <code>nchunk</code> 块以 <code>name</code> 为名保存在 <code>dir</code>中。<code>kcubeIndices</code> 同于计算不同分区间重复的部分。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveCurrent-Tuple{Any}" href="#MoM_Kernels.saveCurrent-Tuple{Any}"><code>MoM_Kernels.saveCurrent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>保存电流系数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveGeoInterval-Tuple{Any}" href="#MoM_Kernels.saveGeoInterval-Tuple{Any}"><code>MoM_Kernels.saveGeoInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveGeoInterval(meshData[; dir = &quot;temp/GeosInfo&quot;])</code></pre><p>保存网格数据 <code>meshData</code> 中各类型网格的区间。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}" href="#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}"><code>MoM_Kernels.saveGeosInfoChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveGeosInfoChunks(geos::AbstractVector, cubes, name::AbstractString, nchunk::Int[; dir = &quot;&quot;, cubes_ChunksIndices = sizeChunks2idxs(length(cubes), nchunk)])</code></pre><p>将几何信息 <code>geos</code> 根据分块数量 <code>nchunk</code> 和在 <code>cubes</code> 中的分布进行分块并保存。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveLevel" href="#MoM_Kernels.saveLevel"><code>MoM_Kernels.saveLevel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">saveLevel(level[, np = ParallelParams.nprocs; dir=&quot;&quot;, kcubeIndices = nothing])</code></pre><p>将层 <code>level</code> 信息保存，其中的盒子信息由 <a href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>get_partition</code></a> 计算的分块信息部分保存。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveOctree-Tuple{Any}" href="#MoM_Kernels.saveOctree-Tuple{Any}"><code>MoM_Kernels.saveOctree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveOctree(octree[; dir=&quot;&quot;])</code></pre><p>将八叉树 <code>octree</code> 保存在 <code>dir</code> 中。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}" href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}"><code>MoM_Kernels.saveVec2Chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveVec2Chunks(y::AbstractVector, name::AbstractString, indices[; dir = &quot;&quot;, showpmeter = false, message = &quot;&quot;])</code></pre><p>把向量 <code>y</code> 以 <code>name</code> 按索引 <code>indices</code> 块保存在 <code>dir</code> 文件夹中。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}" href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}"><code>MoM_Kernels.saveVec2Chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveVec2Chunks(y::AbstractVector, name::AbstractString, nchunk::Int[; dir = &quot;&quot;])</code></pre><p>把向量 <code>y</code> 以 <code>name</code> 分为 <code>nchunk</code> 块保存在 <code>dir</code> 文件夹中。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer" href="#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer"><code>MoM_Kernels.searchNearCubes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于寻找邻盒子的函数 输入 cubesID3D::Matrix{Int}，(n×3)盒子在本层的三维坐标 levelID::Integer       层编号，（定义大盒子为（“0” 层），叶层为第“n”层</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setBFInterval!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据已经排序好的层的盒子信息，从叶层到顶层更新盒子包含的基函数区间</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real" href="#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real"><code>MoM_Kernels.setBigCube</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算包围目标的大盒子信息 输入： nodes::Matrix{FT}，大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标，或者为构成网格的所有点 leafCubeEdgel::FT，叶层盒子边长，用于计算总层数和大盒子的坐标信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用常数基函数时，同一个盒子不会出现重复值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}" href="#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}"><code>MoM_Kernels.setKidLevelFarNeighbors!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>寻找子层的远亲盒子 输入:: thisLevel::LevelInfo{IT, FT, IPT}, 本层信息 kidLevel::LevelInfo{IT, FT, IPT}， 子层信息</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real" href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>非叶层LevelInfo的构造函数，输入为空间三维坐标数组 levelID::计算层的id leafnodes::Matrix{FT},大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标 cubeEdgel::FT，本层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real" href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setLevelInfo!(nLevels::Integer, leafnodes::Matrix{FT},cubeEdgel::FT, bigCubeLowerCoor::Vec3D{FT}[; 
                IPT = get_Interpolation_Method(MLFMAParams.InterpolationMethod), LT = LevelInfo]) where{FT&lt;:Real}</code></pre><p>叶层 LevelInfo 的构造函数，输入信息：</p><pre><code class="nohighlight hljs">nLevels::IT                 层数，亦为叶层层ID
leafnodes::Matrix{FT}       大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标
cubeEdgel::FT               叶层盒子边长
bigCubeLowerCoor::Vec3D{FT} 大盒子的角坐标
IPT                         插值算法类型
LT = LevelInfo              层类</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelTransFactor!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算 第“2”层 到 叶 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsCubesKidsIn8!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算（nLevel-1）-2 层每层的非空盒子的非空子盒子在其8个子盒子中的位置</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsShiftFactor!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于给输入的本(level)层的盒子与其子盒子之间计算相移因子， 由盒子排列的规律性和相移因子的对称性，可知： 只需要计算8个相移因子，即可用于所有盒子到其子盒子的相移， 且这八个盒子关于原点对称的两两之间的相移因子为共轭关系 计算完成直接保存在 level 不再返回</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}" href="#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}"><code>MoM_Kernels.setVSC₁₂₃ⁿ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setVSC₁₂₃ⁿ!()</code></pre><p>计算体奇异性三个系数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.set_Interpolation_Method!-Tuple{Any}" href="#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}"><code>MoM_Kernels.set_Interpolation_Method!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>设置插值算法</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.set_geosInterval!-Tuple{Any}" href="#MoM_Kernels.set_geosInterval!-Tuple{Any}"><code>MoM_Kernels.set_geosInterval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_geosInterval!(fn)</code></pre><p>通过文件 <code>fn</code> 设置网格数据区间。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.set_leafCubeSize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>设置叶层盒子边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.set_nprocs!-Tuple{}" href="#MoM_Kernels.set_nprocs!-Tuple{}"><code>MoM_Kernels.set_nprocs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_nprocs!([;nprocs=1, np=nprocs])</code></pre><p>设置并行核心数量为 <code>nprocs</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF1(a::FT, b::FT, c::FT, d::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c, d</code>的四边形重合时的奇异性F1项，即 <span>$\int{\int{\frac{1}{R}}dS}$</span> 的解析值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF1(a::FT, b::FT, c::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>的三角形重合时的奇异性F1项，即 <span>$\int{\int{\frac{1}{R}}dS}$</span> 的解析值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF21</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>，面积平方为<code>area2</code>的三角形重合时的奇异性F2项，即 <span>$\int{\int{\frac{\boldsymbol{\rho}_{m}\cdot\boldsymbol{\rho}_{n}}{R}}dS}$</span> 的解析值，该函数处理 m==n 即基函数自作用的情况。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF22</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>，面积平方为<code>area2</code>的三角形重合时的奇异性F2项，即 <span>$\int{\int{\frac{\boldsymbol{\rho}_{m}\cdot\boldsymbol{\rho}_{n}}{R}}dS}$</span> 的解析值，该函数处理 m!=n 即同一三角形的不同基函数作用的情况。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}" href="#MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2cuts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunks2cuts(Asize, chunks)
sizeChunks2cuts(Asize::Int, chunks)
sizeChunks2cuts(Asize, chunks::Int)
sizeChunks2cuts(Asize::Int, chunks::Int)</code></pre><p>将数组大小 <code>Asize</code> 按 <code>chunks</code> 进行分块。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}" href="#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2idxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunks2idxs(Asize, nchunk)</code></pre><p>Borrowed form DistributedArray.jl, get the slice of matrix size Asize on each dimension with nchunk. <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}" href="#MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}"><code>MoM_Kernels.sizeChunksCuts2indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunksCuts2indices(Asize, nchunk, cuts::Tuple)
sizeChunksCuts2indices(Asize, nchunk, cuts::Vector{I}) where{I&lt;:Integer}</code></pre><p>根据数组大小 <code>Asize</code> 分块数量 <code>nchunk</code> 以及各块索引区间 <code>cuts</code> 计算各块的索引。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}" href="#MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}"><code>MoM_Kernels.slicedim2bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicedim2bounds(sz::Int, nc::Int)</code></pre><p>将区间 <code>1:sz</code> 划分为 <code>nc</code> 个区间并返回区间上下界。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.slicedim2partition-Tuple{Any, Int64}" href="#MoM_Kernels.slicedim2partition-Tuple{Any, Int64}"><code>MoM_Kernels.slicedim2partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicedim2bounds(dims, nc::Int)</code></pre><p>将区间 <code>dims</code> 划分为 <code>nc</code> 个区间并返回区间上下界。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number" href="#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(ZnearChunks::ZnearChunksStruct{CT}, level; nbf = 0) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据块状近场阻抗矩阵 <code>ZnearChunks</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT&lt;:Real, CT&lt;:Complex{FT}, LT}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和八叉树 <code>octree</code> 叶层计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, level::LT) where { CT&lt;:Complex, LT &lt;: AbstractLevel}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层信息 <code>level</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT&lt;:Real, CT&lt;:Complex{FT}, LT}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和八叉树 <code>octree</code> 叶层计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, level::LT) where { CT&lt;:Complex, LT &lt;: AbstractLevel}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层信息 <code>level</code> 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h1l-Tuple{Integer, Real}" href="#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h1l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第一类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，适用于 l 为整数，x 为浮点数时算的更快</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第一类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real" href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h1l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h2l-Tuple{Integer, Real}" href="#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h2l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第二类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，，适用于 l 为整数，x 为浮点数时算的更快</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第二类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real" href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h2l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.transOnLevel!-Tuple{Any}" href="#MoM_Kernels.transOnLevel!-Tuple{Any}"><code>MoM_Kernels.transOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>层内转移</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.transOnLevels!-Tuple{Any, Any}" href="#MoM_Kernels.transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.transOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>各层内转移</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real" href="#MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real"><code>MoM_Kernels.truncationLCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>该函数计算八叉树各层截断项数 输入为本层最小盒子的边长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.truncationLCal-Tuple{}" href="#MoM_Kernels.truncationLCal-Tuple{}"><code>MoM_Kernels.truncationLCal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncationLCal(;rel_l) where {FT&lt;:Real}</code></pre><p>该函数计算八叉树各层截断项数 输入为相对波长</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.use_CSR-Tuple{}" href="#MoM_Kernels.use_CSR-Tuple{}"><code>MoM_Kernels.use_CSR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_CSR()
use_CSC()</code></pre><p>设置近场阻抗矩阵是否采用CSR（CSC转置）。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityIg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rgt</code>在体网格<code>volumeCell</code>上的奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gV}  &amp;= \int{g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{d_i\sum_{n}^{SglrOrder}{\frac{coeffgreen(n)}{n+2}I_{RS}^{n-1}}}\\
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIgIvecg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}
volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rgt</code>在体网格<code>volumeCell</code>上的奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gV}  &amp;= \int{g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{d_i\sum_{n}^{SglrOrder}{\frac{coeffgreen(n)}{n+2}I_{RS}^{n-1}}}\\
\boldsymbol{I}_{gV}  &amp;= \int{\boldsymbol{R}g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{\hat{\bm{n}}_i \sum_{n=0}^{SglrOrder}{\frac{coeffgreen(n)}{n+1}I^{n+1}_{RS}}}\\
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityLOpDyad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}
volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rtveclc</code>在体网格<code>volumeCell</code>上的并矢格林函数奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
\overline{I}_{V}  &amp;= \int{(k^2 I + ∇∇)G(R) dV&#39;}
\end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}" href="#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}"><code>MoM_Kernels.writeZtt!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>为适应类型变化而将写入部分单独封装</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.EDGEVmINTriVsID" href="#MoM_Basics.EDGEVmINTriVsID"><code>MoM_Basics.EDGEVmINTriVsID</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>三角形在构建时构成第i个边的两个点为三角形中的除了第i个点的两个点，以下为索引构成第i个边的第一个点（计算边向量被 - 掉）时采用的对应点</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.EDGEVpINTriVsID" href="#MoM_Basics.EDGEVpINTriVsID"><code>MoM_Basics.EDGEVpINTriVsID</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>三角形在构建时构成第i个边的两个点为三角形中的除了第i个点的两个点，以下为索引构成第i个边的第二个点（计算边向量时用于减去第二个点 掉）时采用的对应点</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.ExcitingSources" href="#MoM_Basics.ExcitingSources"><code>MoM_Basics.ExcitingSources</code></a> — <span class="docstring-category">Type</span></header><section><div><p>复合激励类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQ1DID2GQ3DIDVector" href="#MoM_Basics.GQ1DID2GQ3DIDVector"><code>MoM_Basics.GQ1DID2GQ3DIDVector</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>构建从六面体的 高斯求积线性索引 映射到 三维索引的数组</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuad" href="#MoM_Basics.GQPNQuad"><code>MoM_Basics.GQPNQuad</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形正常处理高斯求积时高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuad1D" href="#MoM_Basics.GQPNQuad1D"><code>MoM_Basics.GQPNQuad1D</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形 1 维度高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuad1DSSglr" href="#MoM_Basics.GQPNQuad1DSSglr"><code>MoM_Basics.GQPNQuad1DSSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>处理超奇异性时六面体边界四边形 1 维度高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuad1DSglr" href="#MoM_Basics.GQPNQuad1DSglr"><code>MoM_Basics.GQPNQuad1DSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>处理奇异性时六面体边界四边形 1 维度高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuadSSglr" href="#MoM_Basics.GQPNQuadSSglr"><code>MoM_Basics.GQPNQuadSSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形处理超奇异性时高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.GQPNQuadSglr" href="#MoM_Basics.GQPNQuadSglr"><code>MoM_Basics.GQPNQuadSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形处理奇异性时高斯求积点数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Params" href="#MoM_Basics.Params"><code>MoM_Basics.Params</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>保存仿真参数的实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Precision" href="#MoM_Basics.Precision"><code>MoM_Basics.Precision</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>创建实例控制精度</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.QuadGQInfo" href="#MoM_Basics.QuadGQInfo"><code>MoM_Basics.QuadGQInfo</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形正常处理高斯求积信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.QuadGQInfoSSglr" href="#MoM_Basics.QuadGQInfoSSglr"><code>MoM_Basics.QuadGQInfoSSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形处理超奇异性高斯求积信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.QuadGQInfoSglr" href="#MoM_Basics.QuadGQInfoSglr"><code>MoM_Basics.QuadGQInfoSglr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体边界四边形处理奇异性高斯求积信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SimulationParams" href="#MoM_Basics.SimulationParams"><code>MoM_Basics.SimulationParams</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>非数值仿真参数实例</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VSBFTypes" href="#MoM_Basics.VSBFTypes"><code>MoM_Basics.VSBFTypes</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>创建常数实例保存仿真时的面、体基函数类型。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Vec3IdxCircle" href="#MoM_Basics.Vec3IdxCircle"><code>MoM_Basics.Vec3IdxCircle</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>1-3 的循环</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.facen2OppositeID" href="#MoM_Basics.facen2OppositeID"><code>MoM_Basics.facen2OppositeID</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体的六个面的对面</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.facesVertIDs" href="#MoM_Basics.facesVertIDs"><code>MoM_Basics.facesVertIDs</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体的六个面的端点</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.memory" href="#MoM_Basics.memory"><code>MoM_Basics.memory</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>程序内存记录字典</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.oppFacesVertIDs" href="#MoM_Basics.oppFacesVertIDs"><code>MoM_Basics.oppFacesVertIDs</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>六面体的六个面的 对面的 端点</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.timer" href="#MoM_Basics.timer"><code>MoM_Basics.timer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>程序计时器字典</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.uv2FreeVnsDict" href="#MoM_Basics.uv2FreeVnsDict"><code>MoM_Basics.uv2FreeVnsDict</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>从四边形的 <span>$uv$</span> 坐标映射到 自由端的 id</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.AbstractAntennaArray" href="#MoM_Basics.AbstractAntennaArray"><code>MoM_Basics.AbstractAntennaArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>阵列天线抽象类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.AntennaArray" href="#MoM_Basics.AntennaArray"><code>MoM_Basics.AntennaArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AntennaArray{FT&lt;:Real, AT, N} &lt;: AbstractAntennaArray</code></pre><p>机扫阵列天线 (mechanically scanned array, MSA)、相控阵 (Phased Array)阵列天线 orient 采用的是欧拉角，参考<a href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT, FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>eulerRotationMat</code></a> 注意阵列初始指向由提供的天线单元合成，作为阵列只提供指向旋转。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.AntennaArray-Union{Tuple{AbstractArray{AT, N}}, Tuple{N}, Tuple{AT}} where {AT, N}" href="#MoM_Basics.AntennaArray-Union{Tuple{AbstractArray{AT, N}}, Tuple{N}, Tuple{AT}} where {AT, N}"><code>MoM_Basics.AntennaArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AntennaArray(antennas::AbstractArray{AT, N}; center = zero(MVec3D{Precison.FT}), orient = (0., 0., 0.)) where {AT, N}</code></pre><p>初始化阵列天线，默认为方阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.AntennaType" href="#MoM_Basics.AntennaType"><code>MoM_Basics.AntennaType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>天线抽象类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.BasisFunctionType" href="#MoM_Basics.BasisFunctionType"><code>MoM_Basics.BasisFunctionType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>基函数抽象类型</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.ConstBasisFunction" href="#MoM_Basics.ConstBasisFunction"><code>MoM_Basics.ConstBasisFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>常数基抽象类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.ExcitingSource" href="#MoM_Basics.ExcitingSource"><code>MoM_Basics.ExcitingSource</code></a> — <span class="docstring-category">Type</span></header><section><div><p>激励源抽象类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.HexahedraInfo" href="#MoM_Basics.HexahedraInfo"><code>MoM_Basics.HexahedraInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HexahedraInfo{IT&lt;: Integer, FT&lt;:AbstractFloat, CT&lt;:Complex} &lt;: VolumeCellType{IT, FT, CT}</code></pre><p>六面体信息结构体：</p><pre><code class="nohighlight hljs">hexaID      ::IT                    编号
volume      ::FT                    体积
ε           ::CT                    相对介电常数
κ           ::CT                    介质对比度
center      ::MVec3D{FT}            中心坐标
verticesID  ::MVector{8, IT}        所在节点id
vertices    ::MMatrix{3, 8, FT,24}  六面体4个角点坐标，每列为一个点
facesn̂      ::MMatrix{3, 8, FT,24}  四个面的外法向量
facesvid    ::MMatrix{3, 8, IT,24}  四个面包含的四个id
facesArea   ::MVector{6, FT}        四个面的面积（根据为unitri正负部分赋予正负号）
faces       ::Vector{Quads4Hexa{IT, FT}}    四个面的具体信息
inBfsID     ::Vector{IT}            六面体所在的基函数的ID</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.HexahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.HexahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.HexahedraInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HexahedraInfo{IT, FT, CT}(hexaID::IT = zero(IT)) where {IT &lt;: Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p><code>HexahedraInfo</code> 的默认构造函数，除了输入的编号 <code>hexaID</code> 外所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.HexahedraMesh" href="#MoM_Basics.HexahedraMesh"><code>MoM_Basics.HexahedraMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HexahedraMesh{IT, FT} &lt;: MeshDataType</code></pre><p>六面体网格文件，包括六面体数 <code>hexnum</code>、节点 <code>node</code>、构成六面体的节点 id 数组 <code>hexahedras</code> 等信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.LinearBasisFunction" href="#MoM_Basics.LinearBasisFunction"><code>MoM_Basics.LinearBasisFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>线性基抽象类</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MagneticDipole" href="#MoM_Basics.MagneticDipole"><code>MoM_Basics.MagneticDipole</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MagneticDipole(id = 0; Iml = 0., phase = 0., orient = zero(MVec3D{Float32}), centerlc = zero(MVec3D{Float32}), centergb = zero(MVec3D{Float32}))</code></pre><p>精度可变的 MagneticDipole 构造函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MagneticDipole" href="#MoM_Basics.MagneticDipole"><code>MoM_Basics.MagneticDipole</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MagneticDipole{FT&lt;: Real}&lt;:AntennaType</code></pre><p>磁偶极子天线类型。</p><pre><code class="nohighlight hljs">id      ::Integer               编号
Iml     ::Complex{FT}           磁流线值
V       ::FT                    磁流线幅值
phase   ::FT                    相位
orient  ::MVec3D{FT}            指向欧拉角
centerlc::MVec3D{FT}            局部坐标下的中心位置
centergb::MVec3D{FT}            全局坐标下的中心位置
l2gRot  ::MMatrix{3, 3, FT, 9}  局部坐标到全局坐标的旋转变换矩阵</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MagneticDipole-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Basics.MagneticDipole-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Basics.MagneticDipole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    MagneticDipole{FT}(
    id      ::Int32         =   zero(Int32);        # 编号
    Iml     ::CT            =   zero(CT),           # 磁流线值
    phase   ::FT            =   zero(FT),           # 相位（输入弧度(rad)单位）
    orient  ::MVec3D{FT}    =   zero(MVec3D{FT}),   # 指向欧拉角
    centerlc::MVec3D{FT}    =   zero(MVec3D{FT}),   # 局部坐标下的中心位置
    centergb::MVec3D{FT}    =   zero(MVec3D{FT}),   # 全局坐标下的中心位置
    I0S     ::FT            =   zero(FT),           # 电流环幅值
    unit                    =   :rad    ) 
    where{FT &lt;: Real, CT &lt;: Complex{FT}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MeshDataType" href="#MoM_Basics.MeshDataType"><code>MoM_Basics.MeshDataType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>网格数据抽象类型</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MeshFormat" href="#MoM_Basics.MeshFormat"><code>MoM_Basics.MeshFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>网格文件抽象类型</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.MeshNodeTriTetraHexa" href="#MoM_Basics.MeshNodeTriTetraHexa"><code>MoM_Basics.MeshNodeTriTetraHexa</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeshNodeTriTetraHexa{IT, FT} &lt;: MeshDataType</code></pre><p>三角形、四面体、六面体混合网格数据类型：</p><pre><code class="nohighlight hljs">geonum      ::Int           包含的所有网格元的数量
meshT       ::DataType      网格类型 单一的以其网格类型表示，混合以 VSCellType 表示
trinum      ::Int           包含的三角形数量
tetranum    ::Int           包含的四面体数量
hexanum     ::Int           包含的六面体数量
node        ::Array{FT, 2}  节点坐标数组(3*nodenum)
triangles   ::Array{IT, 2}  三角形包含的nodeid数组:(3*trinum)
tetrahedras ::Array{IT, 2}  四面体包含的nodeid数组:(4*tetranum)
hexahedras  ::Array{IT, 2}  六面体包含的nodeid数组:(6*hexanum)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.NasMesh" href="#MoM_Basics.NasMesh"><code>MoM_Basics.NasMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p>.nas 网格文件类型。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.PWC" href="#MoM_Basics.PWC"><code>MoM_Basics.PWC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PWC{IT&lt;:Integer , FT&lt;:AbstractFloat} &lt;: ConstBasisFunction</code></pre><p>PWC 基函数复合类型：</p><pre><code class="nohighlight hljs">bfID        ::IT            基函数编号
inGeo       ::IT            基函数所在两个四面体编号
center      ::MVec3D{FT}    基函数中心，用于八叉树分组</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.PWC-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.PWC-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.PWC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PWC{IT, FT}() where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p>PWC 的默认构造函数，所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.ParamsType" href="#MoM_Basics.ParamsType"><code>MoM_Basics.ParamsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ParamsType{FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}</p><p>创建参数类型以方便保存仿真参数并控制精度：</p><pre><code class="nohighlight hljs">frequency   ::FT        频率
ω_0         ::FT        角频率
K_0         ::FT        波数
λ_0         ::CT        波长
Jη_0divK    ::CT        常数
JK_0        ::CT        常数
k²          ::FT        常数
divJω       ::CT        常数
mk²div9     ::FT        常数
mJη_0div4πK ::CT        常数
C4divk²     ::FT        常数
JKηdiv16π   ::CT        常数
div9Jω      ::CT        常数
Rsglr       ::FT        处理奇异性的相对距离阈值
resultDir   ::String    存放结果的位置</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.ParamsType-Union{Tuple{CT}, Tuple{FT}} where {FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Basics.ParamsType-Union{Tuple{CT}, Tuple{FT}} where {FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Basics.ParamsType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParamsType{FT, CT}(frequency::FT) where{FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}
ParamsType(frequency::FT) where {FT&lt;:AbstractFloat}
ParamsType{FT}(frequency) where {FT&lt;:AbstractFloat}</code></pre><p>输入频率创建仿真参数实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.PlaneWave" href="#MoM_Basics.PlaneWave"><code>MoM_Basics.PlaneWave</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlaneWave{FT&lt;:Real}&lt;:ExcitingSource</code></pre><p>平面波源：</p><pre><code class="nohighlight hljs">θ   ::FT            球坐标角度θ
ϕ   ::FT            球坐标角度ϕ
α   ::FT            波极化方向相对于 θhat_source 绕K̂_v旋转的角度
f   ::FT            波频率
V   ::FT            波激励幅度
E_v ::SVec3D{FT}    入射波电场极化矢量
k̂   ::SVec3D{FT}    入射波波矢向量</code></pre><p>默认构造函数：</p><pre><code class="language-julia hljs">PlaneWave{FT}(θ::FT, ϕ::FT, α::FT, V::FT = one(FT))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.PlaneWave-Union{Tuple{FT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where FT" href="#MoM_Basics.PlaneWave-Union{Tuple{FT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where FT"><code>MoM_Basics.PlaneWave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlaneWave{FT}(θ, ϕ, α, V = one(FT)) where {FT}</code></pre><p>类型自动转换的 <code>PlaneWave</code> 构造函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.PrecisionT" href="#MoM_Basics.PrecisionT"><code>MoM_Basics.PrecisionT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建类型用于控制程序精度</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Quads4Hexa" href="#MoM_Basics.Quads4Hexa"><code>MoM_Basics.Quads4Hexa</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Quads4Hexa{IT&lt;: Integer, FT&lt;:AbstractFloat} &lt;: SurfaceCellType{IT, FT}</code></pre><p>单个构成六面体的四边形信息：</p><pre><code class="nohighlight hljs">isbd        ::Bool                  是否在体区域边界，
δκ          ::Complex{FT}           介质对比度变化量，
vertices    ::MMatrix{3, 4, FT, 12} 四边形 4 个角点坐标，每列为一个点，
edgel       ::MVector{4, FT}        四个边长，
edgev̂       ::MMatrix{3, 4, FT, 12} 四个边的单位指向向量，
edgen̂       ::MMatrix{3, 4, FT, 12} 四个边的单位外法向量。</code></pre><p>合理安排位置后，四个基函数的自由端即为四边形四个点的顺序。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Quads4Hexa-Union{Tuple{FT}, Tuple{FT, FT}} where FT" href="#MoM_Basics.Quads4Hexa-Union{Tuple{FT}, Tuple{FT, FT}} where FT"><code>MoM_Basics.Quads4Hexa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(q::Quads4Hexa)(u::FT, v::FT) where {FT}</code></pre><p>计算六面体边界四边形在局部坐标 <code>(u, v)</code> 下的点。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Quads4Hexa-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.Quads4Hexa-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.Quads4Hexa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Quads4Hexa{IT, FT}() where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p>Quads4Hexa的默认构造函数，默认为边界，其它所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.RBF" href="#MoM_Basics.RBF"><code>MoM_Basics.RBF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RBF{IT&lt;:Integer , FT&lt;:AbstractFloat} &lt;: LinearBasisFunction</code></pre><p>屋顶基函数 (Rooftop basis function, RBF) 基函数复合类型：</p><pre><code class="nohighlight hljs">isbd        ::Bool              是否为边界元即半基函数，布尔类型
bfID        ::IT                基函数编号，整形
inGeo       ::MVector{2, IT}    基函数所在两个六面体编号（半基函数为1个，赋值成一样的两个），长度为2的向量数组
inGeoID     ::MVector{2, IT}    基函数在两个六面体中的局部编号（半基函数为1个，赋值成一样的两个），取值1:4，长度为2的向量数组
center      ::MVec3D{FT}        基函数中心，用于八叉树分组</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.RBF-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.RBF-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.RBF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RBF{IT, FT}() where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p>RBF 的默认构造函数，所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.RWG" href="#MoM_Basics.RWG"><code>MoM_Basics.RWG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RWG{IT&lt;:Integer , FT&lt;:AbstractFloat} &lt;: LinearBasisFunction</code></pre><p>RWG基函数复合类型：</p><pre><code class="nohighlight hljs">isbd        ::Bool              是否为边界元即半基函数，布尔类型
bfID        ::IT                基函数编号，整形
edgel       ::FT                基函数边长，浮点型
inGeo       ::MVector{2, IT}    基函数所在两个三角形编号（半基函数为1个，赋值成一样的两个），长度为2的向量数组
inGeoID     ::MVector{2, IT}    基函数在两个上面三角形中的局部编号（半基函数为1个，赋值成一样的两个），取值1:3，长度为2的向量数组
center      ::MVec3D{FT}        基函数中心，用于八叉树分组</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.RWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.RWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.RWG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RWG{IT, FT}()where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p>RWG 的默认构造函数，默认非面的边界，所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SWG" href="#MoM_Basics.SWG"><code>MoM_Basics.SWG</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SWG 基函数复合类型参数解释：</p><pre><code class="nohighlight hljs">isbd        ::Bool              是否为边界元即半基函数
bfID        ::IT                基函数编号，整形
inGeo       ::MVector{2, IT}    基函数所在两个四面体编号（半基函数为1个，赋值成一样的两个），长度为2的向量数组
inGeoID     ::MVector{2, IT}    基函数在两个四面体中的局部编号（半基函数为1个，赋值成一样的两个），取值1:4，长度为2的向量数组
center      ::MVec3D{FT}        基函数公共面中心，用于八叉树分组</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.SWG-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.SWG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWG{IT, FT}() where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p>SWG 的默认构造函数，所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SimulationParamsType" href="#MoM_Basics.SimulationParamsType"><code>MoM_Basics.SimulationParamsType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimulationParamsType</code></pre><p>非数值仿真参数信息：</p><pre><code class="nohighlight hljs">resultDir   ::String        结果文件夹路径
ieT         ::Symbol        积分方程类型，包括 EFIE, MFIE, CFIE等
meshfilename::String        网格文件名称
meshunit    ::Symbol        网格文件单位
SHOWIMAGE   ::Bool          根是否要在前端显示图片
discreteVar ::String        离散的体未知量类型，支持位移电流 `&quot;D&quot;` 或等效电流 `&quot;J&quot;`
sbfT        ::Symbol        面基函数类型，目前仅支持 `:RWG`
vbfT        ::Symbol        体基函数类型，目前支持 `:SWG, :RBF, :PWC`</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SimulationParamsType-Tuple{}" href="#MoM_Basics.SimulationParamsType-Tuple{}"><code>MoM_Basics.SimulationParamsType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimulationParamsType(;ieT::Symbol=:EFIE, meshfilename::String = &quot;&quot;, meshunit::Symbol = :mm, 
SHOWIMAGE = true, discreteVar = &quot;D&quot;, sbfT = :RWG, vbfT = :nothing)</code></pre><p><code>SimulationParamsType</code> 的默认构造函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.SurfaceCellType" href="#MoM_Basics.SurfaceCellType"><code>MoM_Basics.SurfaceCellType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>面元</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TetrahedraInfo" href="#MoM_Basics.TetrahedraInfo"><code>MoM_Basics.TetrahedraInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TetrahedraInfo{IT&lt;: Integer, FT&lt;:AbstractFloat, CT&lt;:Complex} &lt;: VolumeCellType{IT, FT, CT}</code></pre><p>四面体信息结构体：</p><pre><code class="nohighlight hljs">tetraID     ::IT                    编号
volume      ::FT                    体积
ε           ::CT                    相对介电常数
κ           ::CT                    介质对比度
center      ::MVec3D{FT}            中心坐标
verticesID  ::MVector{4, IT}        所在节点id
vertices    ::MMatrix{3, 4, FT, 12} 四面体4个角点坐标，每列为一个点
facesn̂      ::MMatrix{3, 4, FT, 12} 四个面的外法向量
facesvid    ::MMatrix{3, 4, IT, 12} 四个面包含的三个id
facesArea   ::MVector{4, FT}        四个面的面积（根据为unitri正负部分赋予正负号）
faces       ::Vector{Tris4Tetra{IT, FT}}    四个面的具体信息
inBfsID     ::Vector{IT}            四面体所在的基函数的ID</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TetrahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.TetrahedraInfo-Union{Tuple{}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.TetrahedraInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TetrahedraInfo{IT, FT, CT}(hexaID::IT = zero(IT)) where {IT &lt;: Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p><code>TetrahedraInfo</code> 的默认构造函数，除了输入的编号 <code>tetraID</code> 外所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TetrahedraMesh" href="#MoM_Basics.TetrahedraMesh"><code>MoM_Basics.TetrahedraMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HexahedraMesh{IT, FT} &lt;: MeshDataType</code></pre><p>四面体网格文件，包括四面体数 <code>tetranum</code>、节点 <code>node</code>、构成四面体的节点 id 数组 <code>tetrahedras</code> 等信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TriangleInfo" href="#MoM_Basics.TriangleInfo"><code>MoM_Basics.TriangleInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriangleInfo{IT&lt;: Integer, FT&lt;:AbstractFloat} &lt;: SurfaceCellType{IT, FT}</code></pre><p>三角形信息结构体：</p><pre><code class="nohighlight hljs">triID       ::IT                    编号
area        ::FT                    面积
verticesID  ::MVector{3, IT}        所在节点id
vertices    ::MMatrix{3, 3, FT, 9}  三角形3个角点坐标，每列为一个点
center      ::MVec3D{FT}            中心坐标
facen̂       ::MVec3D{FT}            面的外法向量
edgel       ::MVec3D                三边长
edgev̂       ::MMatrix{3, 3, FT, 9}  三个边的指向向量
edgen̂       ::MMatrix{3, 3, FT, 9}  三个边的外法向量
inBfsID     ::MVector{3, IT}        三角形所在的三个基函数的ID</code></pre><p>合理安排位置后，三个基函数的自由端即为三角形三个点的顺序。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TriangleInfo-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.TriangleInfo-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.TriangleInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TriangleInfo{IT, FT}(triID::IT = zero(IT)) where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p><code>TriangleInfo</code> 的默认构造函数，除了输入的编号 <code>triID</code> 外所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.TriangleMesh" href="#MoM_Basics.TriangleMesh"><code>MoM_Basics.TriangleMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriangleMesh{IT, FT} &lt;: MeshDataType</code></pre><p>三角形网格文件，包括三角形数 <code>trinum</code>、节点 <code>node</code>、构成三角形的节点 id 数组 <code>triangles</code> 等信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Tris4Tetra" href="#MoM_Basics.Tris4Tetra"><code>MoM_Basics.Tris4Tetra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriangleInfo{IT&lt;: Integer, FT&lt;:AbstractFloat} &lt;: SurfaceCellType{IT, FT}</code></pre><p>构成四面体的三角形信息结构体：</p><pre><code class="nohighlight hljs">isbd        ::Bool                  是否在边界上
δκ          ::Complex{FT}           面两侧介质对比度差值
vertices    ::MMatrix{3, 3, FT, 9}  三角形3个角点坐标，每列为一个点
edgel       ::MVec3D{FT}            三边长
edgev̂       ::MMatrix{3, 3, FT, 9}  三个边的指向向量
edgen̂       ::MMatrix{3, 3, FT, 9}  三个边的外法向量</code></pre><p>合理安排位置后，三个基函数的自由端即为三角形三个点的顺序。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.Tris4Tetra-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.Tris4Tetra-Union{Tuple{}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.Tris4Tetra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Tris4Tetra{IT, FT}() where {IT &lt;: Integer, FT&lt;:AbstractFloat}</code></pre><p><code>Tris4Tetra</code> 的默认构造函数，默认在边界上，其它所有元素置零。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VSBFTstruct" href="#MoM_Basics.VSBFTstruct"><code>MoM_Basics.VSBFTstruct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建结构体保存面、体基函数类型。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VSCellType" href="#MoM_Basics.VSCellType"><code>MoM_Basics.VSCellType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>网格体、面元</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VecCart2SphereMat" href="#MoM_Basics.VecCart2SphereMat"><code>MoM_Basics.VecCart2SphereMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VecCart2SphereMat{T} &lt;: FieldVector{3, Vec3D{T}}</code></pre><p>矢量坐标系（直角 → 球）转换矩阵</p><pre><code class="nohighlight hljs">r_hat   ::  Vec3DCart{T}    r 方向的单位向量
θ_hat   ::  Vec3DCart{T}    θ 方向的单位向量
ϕ_hat   ::  Vec3DCart{T}    ϕ 方向的单位向量</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VecCart2SphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#MoM_Basics.VecCart2SphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.VecCart2SphereMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VecCart2SphereMat{FT}(θϕ::θϕInfo{FT}) where{FT&lt;:AbstractFloat}</code></pre><p><code>VecCart2SphereMat</code>在给定方向 <code>θϕ</code> 的构造函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.VolumeCellType" href="#MoM_Basics.VolumeCellType"><code>MoM_Basics.VolumeCellType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>体元</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.r̂θϕInfo" href="#MoM_Basics.r̂θϕInfo"><code>MoM_Basics.r̂θϕInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">r̂θϕInfo{FT&lt;:Real}</code></pre><p>r̂ θ ϕ 空间角度信息类型，保存以避免大量重复计算</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.r̂θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Basics.r̂θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.r̂θϕInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r̂θϕInfo{FT}(rvec::AbstractVector{FT}) where {FT&lt;:Real}</code></pre><p>输入直角坐标角度 <code>rvec</code> 构造 <code>r̂θϕInfo</code> 实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.r̂θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real" href="#MoM_Basics.r̂θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real"><code>MoM_Basics.r̂θϕInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r̂θϕInfo(θ::FT = zero(FT), ϕ::FT = zero(FT)) where {FT&lt;:Real}
r̂θϕInfo(θ::∠Info{FT}, ϕ::∠Info{FT}) where {FT&lt;:Real}
r̂θϕInfo(θ::FT, ϕ::∠Info{FT}) where {FT&lt;:Real}
r̂θϕInfo(θ::∠Info{FT}, ϕ::FT) where {FT&lt;:Real}</code></pre><p>r̂θϕInfo 的构造函数 输入角度 <code>θ</code> 和 <code>ϕ</code> 构造 <code>r̂θϕInfo</code> 实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.θϕInfo" href="#MoM_Basics.θϕInfo"><code>MoM_Basics.θϕInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">θϕInfo{FT&lt;:Real}</code></pre><p>θ ϕ 空间角度信息类型，保存以避免大量重复计算。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Basics.θϕInfo-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">θϕInfo{FT}(rvec::AbstractVector{FT}) where {FT&lt;:Real}</code></pre><p>输入直角坐标角度 <code>rvec</code> 构造 <code>θϕInfo</code> 实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real" href="#MoM_Basics.θϕInfo-Union{Tuple{}, Tuple{FT}, Tuple{FT, FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">θϕInfo{FT}(θ::FT = zero(FT), ϕ::FT = zero(FT)) where {FT&lt;:Real}
θϕInfo(θ::FT, ϕ::FT) where {FT&lt;:Real}
θϕInfo{FT}(θ::∠Info{FT}, ϕ::∠Info{FT}) where {FT&lt;:Real}
θϕInfo{FT}(θ::FT, ϕ::∠Info{FT}) where {FT&lt;:Real}
θϕInfo{FT}(θ::∠Info{FT}, ϕ::FT) where {FT&lt;:Real}</code></pre><p>输入角度 <code>θ</code> 和 <code>ϕ</code> 构造 <code>θϕInfo</code> 实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.∠Info" href="#MoM_Basics.∠Info"><code>MoM_Basics.∠Info</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∠Info{FT&lt;:Real}</code></pre><p>∠ 空间角度信息类型，保存以避免大量重复计算。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{FT}, Tuple{T}, Tuple{VecCart2SphereMat{FT}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where {T&lt;:Number, FT&lt;:AbstractFloat}" href="#Base.:*-Union{Tuple{FT}, Tuple{T}, Tuple{VecCart2SphereMat{FT}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where {T&lt;:Number, FT&lt;:AbstractFloat}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(c2smat::VecCart2SphereMat{FT}, vec3D::Vec3D{T}) where {T&lt;:Number, FT&lt;:AbstractFloat}</code></pre><p>重载 * 函数以计算向量在球坐标下的各个分量</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics._nastran_string_to_float-Tuple{Any}" href="#MoM_Basics._nastran_string_to_float-Tuple{Any}"><code>MoM_Basics._nastran_string_to_float</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_nastran_string_to_float(string)</code></pre><p>解析 <code>.nas</code> 文件中的字符串。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.acrossbcrossc-Tuple{Any, Any, Any}" href="#MoM_Basics.acrossbcrossc-Tuple{Any, Any, Any}"><code>MoM_Basics.acrossbcrossc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acrossbcrossc(a, b, c)</code></pre><p>更高效地计算矢量连续叉乘：<span>$a × b × c = (c⋅a)b - (c⋅b)a$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.add_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real" href="#MoM_Basics.add_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real"><code>MoM_Basics.add_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_phase!(md::MagneticDipole{FT}, phase) where {FT &lt;: Real}</code></pre><p>为磁偶极 <code>md</code> 附加相位 <code>phase</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.antennaArray" href="#MoM_Basics.antennaArray"><code>MoM_Basics.antennaArray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">antennaArray(arysize, aryorient, dgap = Tuple(fill(Params.λ_0/2, length(arysize)));
sourceConstructer, sourceT, sourceorientlc[, orientunit=:rad, coefftype = :uniform, arycenter = zero(MVec3D{Precision.FT})])</code></pre><p>提供快捷的阵列构建函数。注意此处输入的阵列、单元指向必须为指定的欧拉角 (ZXZ) <a href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT, FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>eulerRotationMat</code></a>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.boundaryRBF-Tuple{Meshes.Hexahedron}" href="#MoM_Basics.boundaryRBF-Tuple{Meshes.Hexahedron}"><code>MoM_Basics.boundaryRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryRBF(h::Hexahedron)</code></pre><p>重载面的提取顺序以匹配屋顶基函数 (RBF) 在六面体中的面按 </p><p class="math-container">\[u=1, u=0, v = 1, v = 0, w = 1, w = 0 \]</p><p>的顺序排列。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.byte2other-Tuple{Any, Any}" href="#MoM_Basics.byte2other-Tuple{Any, Any}"><code>MoM_Basics.byte2other</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">byte2other(v, mem_unit)</code></pre><p>将以字节为单位的内存数据 <code>v</code> 转换为其它单位 <code>mem_unit</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.cart2sphere-Union{Tuple{Vararg{T, 3}}, Tuple{T}} where T" href="#MoM_Basics.cart2sphere-Union{Tuple{Vararg{T, 3}}, Tuple{T}} where T"><code>MoM_Basics.cart2sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cart2sphere(xyz::Vararg{T, 3}) where {T}</code></pre><p>将直角坐标 <code>xyz</code> 转换到球坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.cart2sphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Basics.cart2sphereMat-Union{Tuple{θϕInfo{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.cart2sphereMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cart2sphereMat(θϕ::θϕInfo{FT}) where{FT&lt;:Real}
cart2sphereMat(θ::FT, ϕ::FT) where{FT&lt;:Real}</code></pre><p>计算矢量坐标系（直角 → 球）转换矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.constructFloat2IndexDict-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#MoM_Basics.constructFloat2IndexDict-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.constructFloat2IndexDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructFloat2IndexDict(floats::AbstractVector{FT}) where {FT&lt;:AbstractFloat}</code></pre><p>构建有序（从小到大）浮点数为键，值为该组数构成的的二重字典，字典值为键的二维数组的线性坐标</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.constructGQ1DID2GQ3DIDVector-Tuple{Any}" href="#MoM_Basics.constructGQ1DID2GQ3DIDVector-Tuple{Any}"><code>MoM_Basics.constructGQ1DID2GQ3DIDVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructGQ1DID2GQ3DIDVector(gqInfo)</code></pre><p>构建从六面体体高斯求积点线性索引到三维索引的数组。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.dist-Union{Tuple{FT}, Tuple{AbstractVector{FT}, AbstractVector{FT}}} where FT&lt;:AbstractFloat" href="#MoM_Basics.dist-Union{Tuple{FT}, Tuple{AbstractVector{FT}, AbstractVector{FT}}} where FT&lt;:AbstractFloat"><code>MoM_Basics.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(pa::AbstractVector{FT}, pb::AbstractVector{FT})::FT where {FT&lt;:AbstractFloat}
dist(pa::Vec3D{FT}, pb::Vec3D{FT})::FT where {FT&lt;:AbstractFloat}
dist(pa::Vec3D{FT})::FT where {FT&lt;:AbstractFloat}</code></pre><p>计算两点之间距离，比使用norm函数更高效。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.eulerRMat2αβγ-Tuple{Any}" href="#MoM_Basics.eulerRMat2αβγ-Tuple{Any}"><code>MoM_Basics.eulerRMat2αβγ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eulerRMat2αβγ(l2gMat)</code></pre><p>通过局部坐标到全局坐标的旋转矩阵 <code>l2gMat</code> 计算欧拉角。 旋转矩阵按绕 “z轴” → “x轴” → “z轴”的顺序，分别旋转 <code>α, β, γ</code> 度得到，本函数计算对应的三个角度 <code>α, β, γ</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT, FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real" href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT, FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerRotationMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eulerRotationMat(α::FT, β::FT, γ::FT, unit::Symbol) where{FT&lt;:Real}</code></pre><p>根据坐标旋转的欧拉角计算旋转矩阵, 定义旋转顺序为： “滚动” → “俯仰” → “偏航”， 即按绕 “z轴” → “x轴” → “z轴”的顺序，分别旋转 α, β, γ 度 <a href="https://en.wikipedia.org/wiki/Euler_angles">Wikipedia-Euler_angles</a> 输入： α, β, γ, 旋转角度信息 unit: 输入角度值单位，默认为 :rad，可选 :deg 输出： rotMat :: SMatrix{3, 3, FT}, 坐标旋转矩阵 rotMat * vec 将 vec 从局部坐标转换回全局坐标</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT}, Tuple{FT, FT, Symbol}} where FT&lt;:AbstractFloat" href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{FT, FT}, Tuple{FT, FT, Symbol}} where FT&lt;:AbstractFloat"><code>MoM_Basics.eulerRotationMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eulerRotationMat(θ::FT, ϕ::FT, unit::Symbol) where{FT&lt;:AbstractFloat}</code></pre><p>计算转到给定指向 <code>θ, ϕ</code> 处的旋转矩阵，旋转一步到位，不发生自旋。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT, Symbol}} where FT&lt;:Real" href="#MoM_Basics.eulerRotationMat-Union{Tuple{FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerRotationMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eulerRotationMat(axis::Vec3D{FT}, θ::FT, unit::Symbol) where{FT&lt;:Real}</code></pre><p>计算天线阵按给定任意轴 <code>axis</code>, 旋转 <code>θ</code>` 角度的旋转矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.eulerZunit-Union{Tuple{FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real" href="#MoM_Basics.eulerZunit-Union{Tuple{FT}, Tuple{FT, FT, FT, Symbol}} where FT&lt;:Real"><code>MoM_Basics.eulerZunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eulerZunit(α::FT, β::FT, γ::FT, unit::Symbol) where{FT&lt;:Real}</code></pre><p>计算给定欧拉角局部坐标 <code>z</code> 轴在全局坐标中的位置单位向量。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getBFTfromCellT-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:TriangleInfo" href="#MoM_Basics.getBFTfromCellT-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Basics.getBFTfromCellT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据网格元（如三角形、四边形、四面体、六面体等）获取基函数信息用于快速计算当前单元采用的基函数</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getBFsFromMeshData-Tuple{Any}" href="#MoM_Basics.getBFsFromMeshData-Tuple{Any}"><code>MoM_Basics.getBFsFromMeshData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getBFsFromMeshData(meshData; sbfT = :nothing, vbfT = :nothing)</code></pre><p>通过网格信息 <code>meshData</code> 创建基函数信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getCellsBFs-Tuple{Any, Any}" href="#MoM_Basics.getCellsBFs-Tuple{Any, Any}"><code>MoM_Basics.getCellsBFs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCellsBFs(meshData, vbfT)</code></pre><p>根据读取的网格数据生成网格元 + 基函数信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getCellsBFsFromFileName-Tuple{Any}" href="#MoM_Basics.getCellsBFsFromFileName-Tuple{Any}"><code>MoM_Basics.getCellsBFsFromFileName</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCellsBFsFromFileName(meshFileName; meshUnit = MeshUnit, sbfT = :RWG, vbfT = :nothing)</code></pre><p>通过文件名 <code>meshFileName</code> 直接读取网格元、创建基函数信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getCellsFromFileName-Tuple{Any}" href="#MoM_Basics.getCellsFromFileName-Tuple{Any}"><code>MoM_Basics.getCellsFromFileName</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCellsFromFileName(meshFileName; meshUnit = MeshUnit, sbfT = :RWG, vbfT = :nothing)</code></pre><p>通过文件名 <code>meshFileName</code> 直接读取网格元。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getConnectionMatrix-Tuple{Any}" href="#MoM_Basics.getConnectionMatrix-Tuple{Any}"><code>MoM_Basics.getConnectionMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getConnectionMatrix(meshData)</code></pre><p>通过 <code>meshData</code> 获取节点与网格元之间的连接稀疏矩阵。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVIDFromGQ3DID-Tuple{Tuple{Int64, Int64, Int64}, Integer}" href="#MoM_Basics.getFreeVIDFromGQ3DID-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVIDFromGQ3DID(GQ3DID::NTuple{3, Int}, i::Integer)</code></pre><p>得到第 i 个面所在的基函数的 正常高斯求积 下，三维坐标为 <code>GQ3DID</code> 的高斯求积点的 “自由端<span>$r₀$</span>” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVIDFromGQ3DIDSSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}" href="#MoM_Basics.getFreeVIDFromGQ3DIDSSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DIDSSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVIDFromGQ3DIDSSglr(GQ3DID::NTuple{3, Int}, i::Integer)</code></pre><p>得到第 i 个面所在的基函数的 处理超奇异性时，三维坐标为 <code>GQ3DID</code> 的高斯求积点的 “自由端<span>$r₀$</span>” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVIDFromGQ3DIDSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}" href="#MoM_Basics.getFreeVIDFromGQ3DIDSglr-Tuple{Tuple{Int64, Int64, Int64}, Integer}"><code>MoM_Basics.getFreeVIDFromGQ3DIDSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVIDFromGQ3DIDSglr(GQ3DID::NTuple{3, Int}, i::Integer)</code></pre><p>得到第 i 个面所在的基函数的 处理奇异性时，三维坐标为 <code>GQ3DID</code> 的高斯求积点的 “自由端<span>$r₀$</span>” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVns-Tuple{HexahedraInfo, Integer}" href="#MoM_Basics.getFreeVns-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVns(hexa::HexahedraInfo, i::Integer)</code></pre><p>得到六面体 <code>hexa</code> 第 <code>i</code> 个所在的基函数的 所有自由端( <span>$r₀$</span> )。 该面定义为 <span>$uvw$</span> 坐标中某值为 <span>$1(0)$</span> 的面， 自由端应定义为在该面的 <span>$uvw$</span> 坐标中，将该值赋值为 <span>$0(1)$</span> 时计算得到的点 如 <span>$u = 1$</span> 的面为六面体的第 <span>$(2,6,7,3)$</span> 个点构成的面，<span>$r₀$</span> 为 <span>$uvw$</span>  坐标为 <span>$(0, v, w)$</span> 的点，此点等同于 <span>$u = 0$</span> 的面的四边形的参数坐标为 (v, w) 的点  在构造 RBF 时面按照 按 <span>$u=1, u=0, v = 1, v = 0, w = 1, w = 0$</span> 的顺序排列,  因此函数根据输入的面的序号进行计算。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVnsSSglr-Tuple{HexahedraInfo, Integer}" href="#MoM_Basics.getFreeVnsSSglr-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVnsSSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVnsSSglr(hexa::HexahedraInfo, i::Integer)</code></pre><p>得到六面体 <code>hexa</code> 处理超奇异性时第 <code>i</code> 个所在的基函数的 所有自由端( <span>$r₀$</span> )。 定义详见<a href="#MoM_Basics.getFreeVns-Tuple{HexahedraInfo, Integer}"><code>getFreeVns</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getFreeVnsSglr-Tuple{HexahedraInfo, Integer}" href="#MoM_Basics.getFreeVnsSglr-Tuple{HexahedraInfo, Integer}"><code>MoM_Basics.getFreeVnsSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFreeVns(hexa::HexahedraInfo, i::Integer)</code></pre><p>得到六面体 <code>hexa</code> 处理奇异性时第 <code>i</code> 个所在的基函数的 所有自由端( <span>$r₀$</span> )。 定义详见<a href="#MoM_Basics.getFreeVns-Tuple{HexahedraInfo, Integer}"><code>getFreeVns</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPHexa-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPHexa-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPHexa(hexa::HexahedraInfo, ii::IT) where {IT &lt;: Integer}
getGQPHexa(hexa::HexahedraInfo)</code></pre><p>计算 <code>hexa</code> 正常求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPHexaSSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPHexaSSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexaSSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPHexaSSglr(hexa::HexahedraInfo, ii::IT) where {IT &lt;: Integer}
getGQPHexaSSglr(hexa::HexahedraInfo)</code></pre><p>计算 <code>hexa</code> 处理超奇异性求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPHexaSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPHexaSglr-Union{Tuple{IT}, Tuple{HexahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPHexaSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPHexaSglr(hexa::HexahedraInfo, ii::IT) where {IT &lt;: Integer}
getGQPHexaSglr(hexa::HexahedraInfo)</code></pre><p>计算 <code>hexa</code> 处理奇异性求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPQuad-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPQuad-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPQuad(quad::Quads4Hexa, ii::IT) where {IT &lt;: Integer}
getGQPQuad(quad::Quads4Hexa)</code></pre><p>计算 <code>quad</code> 正常求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPQuadSSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPQuadSSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuadSSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPQuadSSglr(quad::Quads4Hexa, ii::IT) where {IT &lt;: Integer}
getGQPQuadSSglr(quad::Quads4Hexa)</code></pre><p>计算 <code>quad</code> 处理超奇异性的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPQuadSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPQuadSglr-Union{Tuple{IT}, Tuple{Quads4Hexa, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPQuadSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPQuadSglr(quad::Quads4Hexa, ii::IT) where {IT &lt;: Integer}
getGQPQuadSglr(quad::Quads4Hexa)</code></pre><p>计算 <code>quad</code> 处理奇异性的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTetra-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTetra-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTetra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTetra(tetra::TetrahedraInfo, i::IT) where {IT &lt;: Integer}
getGQPTetra(tetra::TetrahedraInfo)</code></pre><p>计算 <code>tetra</code> 正常求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTetraSglr-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTetraSglr-Union{Tuple{IT}, Tuple{TetrahedraInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTetraSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTetraSglr(tetra::TetrahedraInfo, i::IT) where {IT &lt;: Integer}
getGQPTetraSglr(tetra::TetrahedraInfo)</code></pre><p>计算 <code>tetra</code> 处理奇异性求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTri(tri::TriangleInfo, i::IT) where {IT &lt;: Integer}
getGQPTri(tri::TriangleInfo)</code></pre><p>计算 <code>tri</code> 正常求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTri-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTri(tri::Tris4Tetra, i::IT) where {IT &lt;: Integer}
getGQPTri(tri::Tris4Tetra)</code></pre><p>计算 <code>tri</code> 正常求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{TriangleInfo, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTriSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTriSglr(tri::TriangleInfo, i::IT) where {IT &lt;: Integer}
getGQPTriSglr(tri::TriangleInfo)</code></pre><p>计算 <code>tri</code> 处理奇异性求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer" href="#MoM_Basics.getGQPTriSglr-Union{Tuple{IT}, Tuple{Tris4Tetra, IT}} where IT&lt;:Integer"><code>MoM_Basics.getGQPTriSglr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGQPTriSglr(tri::Tris4Tetra, i::IT) where {IT &lt;: Integer}
getGQPTriSglr(tri::Tris4Tetra)</code></pre><p>计算 <code>tri</code> 处理奇异性求积的第 <code>i</code> 个或所有高斯求积坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getHexasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Symbol}} where {IT, FT}" href="#MoM_Basics.getHexasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Symbol}} where {IT, FT}"><code>MoM_Basics.getHexasInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getHexasInfo(hexameshData::HexahedraMesh{IT, FT}, VolumeBFType::Symbol) where{IT, FT}</code></pre><p>根据六面体网格信息 <code>hexameshData</code> 和体基函数类型 <code>VolumeBFType</code> 生成网格信息向量 <code>hexasInfo</code> 和基函数信息向量 <code>bfsInfo</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getMeshData-Tuple{String}" href="#MoM_Basics.getMeshData-Tuple{String}"><code>MoM_Basics.getMeshData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMeshData(meshFileName::String; meshUnit=:mm)</code></pre><p>读取文件中的节点坐标、三角形点、四面体点、六面体点</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getNodeTriTetraFekoNas-Union{Tuple{T}, Tuple{ST}, Tuple{ST, Type{T}}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}" href="#MoM_Basics.getNodeTriTetraFekoNas-Union{Tuple{T}, Tuple{ST}, Tuple{ST, Type{T}}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getNodeTriTetraFekoNas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNodeTriTetraFekoNas(pathname::ST, FT::Type{T}=Precision.FT) where {ST &lt;: AbstractString,T&lt;:AbstractFloat}</code></pre><p>读取 <code>.nas</code> 文件中的节点坐标、三角形点、四面体点。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getNodeTriTetraHexaNas-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}" href="#MoM_Basics.getNodeTriTetraHexaNas-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getNodeTriTetraHexaNas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNodeTriTetraHexaNas(pathname::ST; FT::Type{T}=Precision.FT, meshUnit = :mm) where {ST &lt;: AbstractString,T&lt;:AbstractFloat}</code></pre><p>读取 <code>.nas</code> 文件中的节点坐标、三角形点、四面体点、六面体点。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getTetrasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Symbol}} where {IT, FT}" href="#MoM_Basics.getTetrasInfo-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Symbol}} where {IT, FT}"><code>MoM_Basics.getTetrasInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getTetrasInfo(tetrameshData::TetrahedraMesh{IT, FT}, VolumeBFType::Symbol) where{IT, FT}</code></pre><p>根据四面体网格信息 <code>tetrameshData</code> 和体基函数类型 <code>VolumeBFType</code> 生成网格信息向量 <code>tetrasInfo</code> 和基函数信息向量 <code>bfsInfo</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getTriangleInfo-Union{Tuple{TriangleMesh{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}" href="#MoM_Basics.getTriangleInfo-Union{Tuple{TriangleMesh{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}"><code>MoM_Basics.getTriangleInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getTriangleInfo(trianglemeshData::TriangleMesh{IT, FT}) where{IT, FT}</code></pre><p>根据网格信息 <code>trianglemeshData</code> 生成三角形信息 <code>trianglesInfo</code> 、RWG基函数信息 <code>rwgsInfo</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.getdatNodeElementParam-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}" href="#MoM_Basics.getdatNodeElementParam-Union{Tuple{T}, Tuple{ST}} where {ST&lt;:AbstractString, T&lt;:AbstractFloat}"><code>MoM_Basics.getdatNodeElementParam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getdatNodeElementParam(pathname::ST; FT::Type{T}=Precision.FT, meshUnit = :m) where {ST &lt;: AbstractString,T&lt;:AbstractFloat}</code></pre><p>读取 <code>.dat</code> 格式的自定义项目文件。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.globalObs2LocalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT" href="#MoM_Basics.globalObs2LocalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT"><code>MoM_Basics.globalObs2LocalObs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalObs2LocalObs(r̂θϕs_obs::Matrix{r̂θϕInfo{FT}}, l2gRot::StaticMatrix{3,3, FT}) where {FT}</code></pre><p>根据全局观测空间角度信息 <code>r̂θϕs_obs</code> 计算给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下局部坐标的观测空间角度信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalrvec2Local(rvecglobal::Vec3D{T}, l2gRot::StaticMatrix{3,3, FT}, r0InGlobal::Vec3D{FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算全局向量 <code>rvecglobal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的局部坐标，局部坐标的原点在全局坐标的 <code>r0InGlobal</code> 处。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalrvec2Local(rvecglobal::Vec3D{T}, l2gRot::StaticMatrix{3,3, FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算全局向量 <code>rvecglobal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的局部坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalrvec2Local(rvecsglobal::Matrix{T}, l2gRot::StaticMatrix{3,3, FT}, r0InGlobal::Vec3D{FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算全局向量组成的矩阵 <code>rvecsglobal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的局部坐标，局部坐标的原点在全局坐标的 <code>r0InGlobal</code> 处。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.globalrvec2Local-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.globalrvec2Local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalrvec2Local(rvecsglobal::Matrix{T}, l2gRot::StaticMatrix{3,3, FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算全局向量组成的矩阵 <code>rvecsglobal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的局部坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.greenfunc-Tuple{T} where T&lt;:AbstractFloat" href="#MoM_Basics.greenfunc-Tuple{T} where T&lt;:AbstractFloat"><code>MoM_Basics.greenfunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greenfunc(R::T) where {T&lt;:AbstractFloat}
greenfunc(pa::Vec3D{T}, pb::Vec3D{T}) where {T&lt;:AbstractFloat}
greenfunc(pa::AbstractVector{T}, pb::AbstractVector{T}) where {T&lt;:AbstractFloat}
greenfunc(R::T, k::T) where {T&lt;:AbstractFloat}
greenfunc(pa::Vec3D{T}, pb::Vec3D{T}, k::T) where {T&lt;:AbstractFloat}</code></pre><p>计算归一化自由空间格林函数 <span>$g(R) =  exp^{-1im*K_0*R}/R$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.initialize_time_and_mem-Tuple{}" href="#MoM_Basics.initialize_time_and_mem-Tuple{}"><code>MoM_Basics.initialize_time_and_mem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_time_and_mem()</code></pre><p>初始化计时器 <code>timer</code> 和内存记录 <code>memory</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.inputBasicParameters-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#MoM_Basics.inputBasicParameters-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Basics.inputBasicParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputBasicParameters(;frequency::FT = 1e8, ieT::Symbol = :EFIE, CFIEα::FT = 0.6,
meshfilename::String = SimulationParams.meshfilename) where {FT&lt;:AbstractFloat}</code></pre><p>输入频率参数 <code>frequency</code>，修改其它仿真参数的函数； 积分方程类型参数 <code>ieT</code>，修改计算过程中采用的积分方程； CFIE混合系数 <code>CFIEα</code>、网格文件名 <code>meshfilename</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.localObs2GlobalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT" href="#MoM_Basics.localObs2GlobalObs-Union{Tuple{FT}, Tuple{Array{r̂θϕInfo{FT}, 2}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where FT"><code>MoM_Basics.localObs2GlobalObs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localObs2GlobalObs(r̂θϕs_obs::Matrix{r̂θϕInfo{FT}}, l2gRot::StaticMatrix{3,3, FT}) where {FT}</code></pre><p>根据局部观测空间角度信息 <code>r̂θϕs_obs</code> 计算给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下全局坐标的观测空间角度信息。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localrvec2Global(rvecslocal::Vec3D{T}, l2gRot::StaticMatrix{3,3, FT}, r0InGlobal::Vec3D{FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算局部向量 <code>rveclocal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的全局坐标，局部坐标的原点在全局坐标的 <code>r0InGlobal</code> 处。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localrvec2Global(rvecslocal::Vec3D{T}, l2gRot::StaticMatrix{3,3, FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算局部向量 <code>rveclocal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的全局坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}, AbstractVector{FT}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localrvec2Global(rvecslocal::Matrix{T}, l2gRot::StaticMatrix{3,3, FT}, r0InGlobal::Vec3D{FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算局部向量组成的矩阵 <code>rvecslocal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的全局坐标，局部坐标的原点在全局坐标的 <code>r0InGlobal</code> 处。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}" href="#MoM_Basics.localrvec2Global-Union{Tuple{FT}, Tuple{T}, Tuple{Matrix{T}, StaticArraysCore.StaticArray{Tuple{3, 3}, FT, 2}}} where {T&lt;:Number, FT&lt;:Real}"><code>MoM_Basics.localrvec2Global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localrvec2Global(rvecslocal::Matrix{T}, l2gRot::StaticMatrix{3,3, FT}) where {T&lt;:Number, FT&lt;:Real}</code></pre><p>计算局部向量组成的矩阵 <code>rvecslocal</code> 在给定局部至全局坐标旋转矩阵 <code>l2gRot</code> 下的全局坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.modiParams!-NTuple{16, Any}" href="#MoM_Basics.modiParams!-NTuple{16, Any}"><code>MoM_Basics.modiParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modiParams!(   frequency, ω_0, K_0, λ_0, JKη_0, Jη_0divK, JK_0,
                    k², divJω, mk²div9, mJη_0div4πK, 
                    C4divk², JKηdiv16π, div9Jω, Rsglr, CFIEα)</code></pre><p>输入所有参数修改仿真参数的实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.modiSimulationParams!-Tuple{}" href="#MoM_Basics.modiSimulationParams!-Tuple{}"><code>MoM_Basics.modiSimulationParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modiSimulationParams!(;ieT::Symbol=SimulationParams.ieT, 
meshfilename::String = SimulationParams.meshfilename, 
meshunit = SimulationParams.meshunit,
SHOWIMAGE = SimulationParams.SHOWIMAGE,
discreteVar = SimulationParams.discreteVar
)</code></pre><p>ieT         ::Symbol, 积分方程类型，包括 EFIE, MFIE, CFIE等</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.nodes2Poles-Union{Tuple{Matrix{FT}}, Tuple{FT}} where FT" href="#MoM_Basics.nodes2Poles-Union{Tuple{Matrix{FT}}, Tuple{FT}} where FT"><code>MoM_Basics.nodes2Poles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes2Poles(nodes::Matrix{FT}) where {FT}</code></pre><p>将球面散点 <code>nodes</code> 转化为角度信息实例 <code>r̂θϕInfo</code> 数组。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.radiationDirectionCoeff-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real" href="#MoM_Basics.radiationDirectionCoeff-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationDirectionCoeff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>radiationDirectionCoeff(md::MagneticDipole{FT}, θϕ::θϕInfo{FT}) where {FT&lt;:Real}</p><p>计算方向性系数：<span>$D_m(θ, ϕ) = 4π U_m(θ, ϕ)/P_{rad}$</span>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.radiationIntegralL0-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real" href="#MoM_Basics.radiationIntegralL0-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationIntegralL0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radiationIntegralL0(md::MagneticDipole, θϕ::θϕInfo{FT}) where {FT&lt;:Real}</code></pre><p>磁偶极子的远场辐射积分计算函数，注意 <code>θϕ</code> 为偶极子的局部坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.radiationIntensityU_m-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real" href="#MoM_Basics.radiationIntensityU_m-Union{Tuple{FT}, Tuple{MagneticDipole, θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.radiationIntensityU_m</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radiationIntensityU_m(md::MagneticDipole{FT}, θϕ::θϕInfo{FT}) where {FT&lt;:Real}</code></pre><p>计算磁流源的辐射强度函数 <span>$U_m(θ, ϕ) = \frac{Y_0}{8λ_0²}(|L_θ|² + |L_ϕ|²)$</span>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.radiationPower-Tuple{MagneticDipole}" href="#MoM_Basics.radiationPower-Tuple{MagneticDipole}"><code>MoM_Basics.radiationPower</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radiationPower(md::MagneticDipole{FT}) where {FT&lt;:Real}</code></pre><p>计算辐射功率。 <span>$P_{rad} = ∫∫  U(θ, ϕ)sinθ  dθdϕ$</span> 对磁偶极子可直接在源缝表面积分： <span>$P_{rad} = ∫∫ |E(r)|²/(2η₀) dxdy$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.random_rhat-Tuple{}" href="#MoM_Basics.random_rhat-Tuple{}"><code>MoM_Basics.random_rhat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_rhat(; FT = Precision.FT)</code></pre><p>随机生成单位向量。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.record_BFsInfo-Tuple{Symbol, Int64}" href="#MoM_Basics.record_BFsInfo-Tuple{Symbol, Int64}"><code>MoM_Basics.record_BFsInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_BFsInfo(bfT::Symbol, nbf::Int; io::IO = Core.stdout)</code></pre><p>在 <code>io</code> 中记录基函数类型 <code>bfT</code> 和数量 <code>nbf</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.record_CellInfo" href="#MoM_Basics.record_CellInfo"><code>MoM_Basics.record_CellInfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">record_CellInfo(io::IO = Core.stdout; ntri = 0, ntetra = 0, nhexa = 0)
record_CellInfo(meshData; io::IO = Core.stdout)</code></pre><p>在 <code>io</code> 中记录网格单元数量 <code>ntri, ntetra, nhexa</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rwgbfConstructerTrianglesInfoModifiers!(trianglemeshData::TriangleMesh, trianglesInfo::Vector{TriangleInfo{IT, FT}}) where {IT&lt;:Integer, FT&lt;:AbstractFloat}</code></pre><p>此函数采用排序算法，将每个边的两个点、在三角形中的对点、三角形、基函数等属性信息放在一个大数组中， 通过对不同的属性排序（如按边所在点随数组排序即可将边相同的点放在一起），即可得到基函数分组信息，以此可构造RWG基函数。 函数完成以下功能：</p><ol><li>构造基函数类型实例数组（类似结构化数组）rwgsInfo记录基函数相关信息，并作为返回值；</li><li>写入三角形类型实例数组trianglesInfo中关于基函数的信息。</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.rwgbfnohalfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.rwgbfnohalfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.rwgbfnohalfConstructerTrianglesInfoModifiers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rwgbfnohalfConstructerTrianglesInfoModifiers!(trianglemeshData::TriangleMesh, trianglesInfo::Vector{TriangleInfo{IT, FT}}) where {IT&lt;:Integer, FT&lt;:AbstractFloat}</code></pre><p>此函数与<a href="#MoM_Basics.rwgbfConstructerTrianglesInfoModifiers!-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleMesh, Array{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>rwgbfConstructerTrianglesInfoModifiers!</code></a>基本一致，不同在于不生成半基函数。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.saveSimulationParams-Tuple{}" href="#MoM_Basics.saveSimulationParams-Tuple{}"><code>MoM_Basics.saveSimulationParams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveSimulationParams(;meshfilename::String = SimulationParams.meshfilename, 
sbfT::Symbol = SimulationParams.sbfT, vbfT::Symbol = SimulationParams.vbfT)</code></pre><p>保存仿真参数到结果文件中。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.second_to_other-Tuple{Any, Any}" href="#MoM_Basics.second_to_other-Tuple{Any, Any}"><code>MoM_Basics.second_to_other</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">second_to_other(v, time_unit)</code></pre><p>将以秒为单位的时间数据 <code>v</code> 转换为其它单位 <code>time_unit</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.selectFreeVnID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT" href="#MoM_Basics.selectFreeVnID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectFreeVnID(uvw::AbstractVector{FT}, i::Integer) where {FT}</code></pre><p>根据 <span>$uvw$</span> 计算得到第 i 个面所在的基函数的 正常高斯求积 时 “自由端( <span>$r₀$</span> )” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.selectFreeVnSSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT" href="#MoM_Basics.selectFreeVnSSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnSSglrID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectFreeVnSSglrID(uvw::AbstractVector{FT}, i::Integer) where {FT}</code></pre><p>根据 <span>$uvw$</span> 得到第 i 个面所在的基函数的 处理超奇异性 求积时 “自由端( <span>$r₀$</span> )” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.selectFreeVnSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT" href="#MoM_Basics.selectFreeVnSglrID-Union{Tuple{FT}, Tuple{AbstractVector{FT}, Integer}} where FT"><code>MoM_Basics.selectFreeVnSglrID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectFreeVnSglrID(uvw::AbstractVector{FT}, i::Integer) where {FT}</code></pre><p>根据 <span>$uvw$</span> 得到第 i 个面所在的基函数的 处理奇异性 求积时 “自由端( <span>$r₀$</span> )” 的序号。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:TriangleInfo, CT&lt;:Complex}" href="#MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:TriangleInfo, CT&lt;:Complex}"><code>MoM_Basics.setGeosPermittivity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setGeosPermittivity!(geosInfo::AbstractVector{VT}, εᵣ::CT = 1.0(1+0im)) where {VT&lt;:TriangleInfo, CT&lt;:Complex}</code></pre><p>设置三角形网格介电常数，目前为空派发以方便体面积分方程计算中的多重派发。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:VSCellType, CT&lt;:Complex}" href="#MoM_Basics.setGeosPermittivity!-Union{Tuple{AbstractVector{VT}}, Tuple{CT}, Tuple{VT}, Tuple{AbstractVector{VT}, CT}} where {VT&lt;:VSCellType, CT&lt;:Complex}"><code>MoM_Basics.setGeosPermittivity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setGeosPermittivity!(geosInfo::AbstractVector{VT}, εᵣ::CT = 1.0(1+0im)) where {VT&lt;:VSCellType, CT&lt;:Complex}
setGeosPermittivity!(geosInfo::AbstractVector{VT}, εᵣs::T) where {VT&lt;:VSCellType, T&lt;:AbstractVector}
setGeosPermittivity!(geosInfo::AbstractVector{VT}, εᵣ::CT = 1.0(1+0im)) where {VT&lt;:AbstractVector, CT&lt;:Complex}</code></pre><p>设置四面体、六面体的介电常数 <code>εᵣ</code> ，并同时设置介质对比度，修改此函数以得到对应的数据。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setHexaCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}, HexahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.setHexaCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}, HexahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setHexaCoor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setHexaCoor!( hexasInfo::Vector{HexahedraInfo{IT, FT, CT}}, hexaMeshData::HexahedraMesh{IT, FT}) where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p>在预分配好的六面体数组 <code>hexasInfo</code> 里写入 <code>hexaMeshData</code> 中对应的六面体编号、点坐标、中心位置数据。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setHexaParam!-Union{Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.setHexaParam!-Union{Tuple{Array{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setHexaParam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setHexaParam!(hexasInfo::Vector{HexahedraInfo{IT, FT, CT}}) where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p>计算六面体体积、面外法向量、面积，并写入 <code>hexasInfo</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setPrecision!-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#MoM_Basics.setPrecision!-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>MoM_Basics.setPrecision!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setPrecision!(FT::Type{T}) where {T&lt;:Union{Float32, Float64}}</code></pre><p>设置仿真精度为 <code>FT</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}" href="#MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}"><code>MoM_Basics.setQuad4Hexas!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setQuad4Hexas!(hexameshData::HexahedraMesh{IT, FT}, hexasInfo::Vector{HexahedraInfo{IT, FT, CT}}, ::Val{:PWC}) where {IT, FT, CT}</code></pre><p>计算构成六面体的所有四边形，并将这些信息写入六面体 <code>hexasInfo</code>，给分片常数 (PWC) 基函数赋值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:RBF}}} where {IT, FT, CT}" href="#MoM_Basics.setQuad4Hexas!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraMesh{IT, FT}, Array{HexahedraInfo{IT, FT, CT}, 1}, Val{:RBF}}} where {IT, FT, CT}"><code>MoM_Basics.setQuad4Hexas!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setQuad4Hexas!(hexameshData::HexahedraMesh{IT, FT}, hexasInfo::Vector{HexahedraInfo{IT, FT, CT}}, ::Val{:RBF}) where {IT, FT, CT}</code></pre><p>计算构成六面体的所有四边形，并写入六面体 <code>hexasInfo</code>，给屋顶基函数 (RBF) 基函数赋值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTetraCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}, MoM_Basics.TetrahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.setTetraCoor!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}, MoM_Basics.TetrahedraMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setTetraCoor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setHexaCoor!( tetrasInfo::Vector{TetrahedraInfo{IT, FT, CT}}, tetraMeshData::TetrahedraMesh{IT, FT}) where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p>在预分配好的四面体数组 <code>tetrasInfo</code> 里写入 <code>tetraMeshData</code> 中对应的四面体编号、点坐标、中心位置数据。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTetraParam!-Union{Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}" href="#MoM_Basics.setTetraParam!-Union{Tuple{Array{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}"><code>MoM_Basics.setTetraParam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setTetraParam!(tetrasInfo::Vector{TetrahedraInfo{IT, FT, CT}}) where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex}</code></pre><p>计算四面体体积、面外法向量、面积，并写入 <code>tetrasInfo</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTriParam!-Tuple{TriangleInfo}" href="#MoM_Basics.setTriParam!-Tuple{TriangleInfo}"><code>MoM_Basics.setTriParam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setTriParam!(triangleInfo::TriangleInfo)</code></pre><p>计算三角形边长、边外法向量、面法向量、面积，直接写入 <code>triangleInfo</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}" href="#MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:PWC}}} where {IT, FT, CT}"><code>MoM_Basics.setTriangles4Tetras!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setTriangles4Tetras!(tetrameshData::TetrahedraMesh{IT, FT}, tetrasInfo::Vector{TetrahedraInfo{IT, FT, CT}}, ::Val{:PWC}) where {IT, FT, CT}</code></pre><p>计算构成四面体的所有三角形，并将这些信息写入四面体 <code>tetrasInfo</code>，给分片常数 (PWC) 基函数赋值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:SWG}}} where {IT, FT, CT}" href="#MoM_Basics.setTriangles4Tetras!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{MoM_Basics.TetrahedraMesh{IT, FT}, Array{TetrahedraInfo{IT, FT, CT}, 1}, Val{:SWG}}} where {IT, FT, CT}"><code>MoM_Basics.setTriangles4Tetras!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setTriangles4Tetras!(tetrameshData::TetrahedraMesh{IT, FT}, tetrasInfo::Vector{TetrahedraInfo{IT, FT, CT}}, ::Val{:SWG}) where {IT, FT, CT}</code></pre><p>计算构成四面体的所有三角形，并将这些信息写入四面体 <code>tetrasInfo</code>，给 SWG 基函数赋值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setTricoor!-Union{Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, TriangleMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Basics.setTricoor!-Union{Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, TriangleMesh{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Basics.setTricoor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setTricoor!( trianglesInfo::Vector{TriangleInfo{IT, FT}}, TriangleMeshData::TriangleMesh{IT, FT}) where {IT&lt;:Integer, FT&lt;:AbstractFloat}</code></pre><p>在预分配好的三角形数组 <code>trianglesInfo</code> 里写入 <code>TriangleMeshData</code> 中对应的三角形编号、点坐标、中心位置数据。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setdiffArray!" href="#MoM_Basics.setdiffArray!"><code>MoM_Basics.setdiffArray!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdiffArray!(ary[, dim = 1])</code></pre><p>将阵列天线 <code>ary</code> 在 <code>dim</code> 方向一半单元设置为反相位，从而实现差方向图。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setδκ!-Union{Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Basics.setδκ!-Union{Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Basics.setδκ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setδκ!(hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>设置六面体网格信息 <code>hexasInfo</code> 中每个面上的介质对比度差值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.setδκ!-Union{Tuple{AbstractVector{VT}}, Tuple{VT}} where VT&lt;:VolumeCellType" href="#MoM_Basics.setδκ!-Union{Tuple{AbstractVector{VT}}, Tuple{VT}} where VT&lt;:VolumeCellType"><code>MoM_Basics.setδκ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setδκ!(geosInfo::AbstractVector{VT}) where {VT&lt;:VolumeCellType}</code></pre><p>设置体网格信息 <code>geosInfo</code> 中每个面上的介质对比度差值。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.show_memory_time" href="#MoM_Basics.show_memory_time"><code>MoM_Basics.show_memory_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_memory_time(io::IO=Core.stdout; mem_unit = :MB, time_unit = :s)</code></pre><p>展示时间内存消耗数据记录。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sincmath-Tuple{T} where T&lt;:Number" href="#MoM_Basics.sincmath-Tuple{T} where T&lt;:Number"><code>MoM_Basics.sincmath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sincmath(x::T) where{T&lt;:Number}</code></pre><p>Julia 自带 <a href="@ref"><code>Base.sinc</code></a> 函数计算的是归一化辛格函数:</p><p><span>$sinc(x)     =   sin(πx)/(πx)$</span></p><p>此处借用 <code>sinc</code>，定义数学领域的非归一化 sinc 函数，即计算:</p><p><span>$sin(x)/x$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceEfield-Tuple{PlaneWave, Any}" href="#MoM_Basics.sourceEfield-Tuple{PlaneWave, Any}"><code>MoM_Basics.sourceEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceEfield(plw::PlaneWave, r)</code></pre><p>计算平面波 <code>plw</code> 在全局坐标下给定位置 <code>r</code> 处的电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}" href="#MoM_Basics.sourceEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceEfield(ary::AT, rvec::AbstractVector{FT}) where {FT&lt;:Real,  AT&lt;:AbstractAntennaArray}</code></pre><p>计算天线阵列 <code>ary</code> 在全局坐标下给定位置 <code>rvec</code> 处的电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real" href="#MoM_Basics.sourceEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceEfield(md::MagneticDipole{FT}, r_observe::Vec3D{FT};  r_coortype::Symbol=:C) where {FT&lt;:Real}</code></pre><p>计算磁偶极 <code>md</code> 在全局坐标下给定位置 <code>rvec</code> 处的电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, AbstractVector{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}" href="#MoM_Basics.sourceEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, AbstractVector{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}"><code>MoM_Basics.sourceEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceEfield(sources::Vector{ST}, rvec::AbstractVector{FT}) where {FT&lt;:Real, ST&lt;:ExcitingSource}</code></pre><p>计算源向量 <code>sources</code> 在全局坐标下给定位置 <code>rvec</code> 处的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}" href="#MoM_Basics.sourceFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceFarEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceFarEfield(ary::AT, r̂θϕ::r̂θϕInfo{FT}) where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}</code></pre><p>计算天线阵列 <code>ary</code> 在全局坐标下给定方向 <code>r̂θϕ</code> 的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real" href="#MoM_Basics.sourceFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceFarEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceFarEfield(md::MagneticDipole{FT}, r̂θϕ::r̂θϕInfo{FT}) where {FT&lt;:Real}</code></pre><p>计算磁偶极 <code>md</code> 在全局坐标下给定方向 <code>r̂θϕ</code> 的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceFarEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, r̂θϕInfo{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}" href="#MoM_Basics.sourceFarEfield-Union{Tuple{ST}, Tuple{FT}, Tuple{Vector{ST}, r̂θϕInfo{FT}}} where {FT&lt;:Real, ST&lt;:ExcitingSource}"><code>MoM_Basics.sourceFarEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceFarEfield(sources::Vector{ST}, r̂θϕ::r̂θϕInfo{FT}) where {FT&lt;:Real, ST&lt;:ExcitingSource}</code></pre><p>计算源向量 <code>sources</code> 在全局坐标下给定方向 <code>r̂θϕ</code> 的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceHfield-Tuple{PlaneWave, Any}" href="#MoM_Basics.sourceHfield-Tuple{PlaneWave, Any}"><code>MoM_Basics.sourceHfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceHfield(plw::PlaneWave, r)</code></pre><p>计算平面波 <code>plw</code> 在全局坐标下给定位置 <code>r</code> 处的磁场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceLocalEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}" href="#MoM_Basics.sourceLocalEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, AbstractVector{FT}}} where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceLocalEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceLocalEfield(ary::AT, rvec::AbstractVector{FT}) where {FT&lt;:Real,  AT&lt;:AbstractAntennaArray}</code></pre><p>计算天线阵列 <code>ary</code> 在阵列局部坐标下给定位置 <code>rvec</code> 处的电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceLocalEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real" href="#MoM_Basics.sourceLocalEfield-Union{Tuple{FT}, Tuple{MagneticDipole, AbstractVector{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceLocalEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceLocalEfield(md::MagneticDipole{FT}, r_observe::Vec3D{FT};  r_coortype::Symbol=:C) where {FT&lt;:Real}</code></pre><p>计算磁偶极 <code>md</code> 在磁偶极局部坐标给定位置 <code>rvec</code> 处的电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceLocalFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}" href="#MoM_Basics.sourceLocalFarEfield-Union{Tuple{AT}, Tuple{FT}, Tuple{AT, r̂θϕInfo{FT}}} where {FT&lt;:AbstractFloat, AT&lt;:AbstractAntennaArray}"><code>MoM_Basics.sourceLocalFarEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceLocalFarEfield(ary::AT, r̂θϕ::r̂θϕInfo{FT}) where {FT&lt;:Real, AT&lt;:AbstractAntennaArray}</code></pre><p>计算天线阵列 <code>ary</code> 在阵列坐标下给定方向 <code>r̂θϕ</code> 的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sourceLocalFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real" href="#MoM_Basics.sourceLocalFarEfield-Union{Tuple{FT}, Tuple{MagneticDipole, r̂θϕInfo{FT}}} where FT&lt;:Real"><code>MoM_Basics.sourceLocalFarEfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sourceLocalFarEfield(md::MagneticDipole{FT}, r̂θϕ::r̂θϕInfo{FT}) where {FT&lt;:Real}</code></pre><p>计算磁偶极 <code>md</code> 在磁偶极局部坐标下给定方向 <code>r̂θϕ</code> 的远场电场。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.sphere2cart-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#MoM_Basics.sphere2cart-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>MoM_Basics.sphere2cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sphere2cart(coor_sphere::AbstractVector{T}) where T&lt;:Real
sphere2cart(coor_sphere...)
sphere2cart(r::T, θϕ::θϕInfo{T}) where T&lt;:Real</code></pre><p>将球坐标 <code>coor_sphere</code> 转换到直角坐标。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.updateVSBFTParams!-Tuple{}" href="#MoM_Basics.updateVSBFTParams!-Tuple{}"><code>MoM_Basics.updateVSBFTParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateVSBFTParams!(;sbfT = :nothing, vbfT = :nothing)</code></pre><p>通过输入符号更新体、面基函数类型常数实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.updateVSBFTypes!-Tuple{}" href="#MoM_Basics.updateVSBFTypes!-Tuple{}"><code>MoM_Basics.updateVSBFTypes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateVSBFTypes!(;sbfType = BasisFunctionType, vbfType = BasisFunctionType)</code></pre><p>更新体、面基函数类型常数实例。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.update_orient!-Tuple{AT} where AT&lt;:AbstractAntennaArray" href="#MoM_Basics.update_orient!-Tuple{AT} where AT&lt;:AbstractAntennaArray"><code>MoM_Basics.update_orient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_orient!(ary::AT; aryorient, sourceorientlc[, orientunit = :rad]) where {AT&lt;:AbstractAntennaArray}</code></pre><p>通过机械旋转更新天线阵列 <code>ary</code> 的阵列指向为 <code>aryorient</code>，天线单元指向为 <code>sourceorientlc</code>，指向角单位为 <code>orientunit</code> 。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.update_orient!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}, Tuple{MagneticDipole{FT}, Any, Any}} where FT&lt;:Real" href="#MoM_Basics.update_orient!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}, Tuple{MagneticDipole{FT}, Any, Any}} where FT&lt;:Real"><code>MoM_Basics.update_orient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_orient!(md::MagneticDipole{FT}, orient, unit = :rad) where {FT &lt;: Real}</code></pre><p>更新磁偶极 <code>md</code> 指向为 <code>orient</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.update_phase!-Union{Tuple{AT}, Tuple{AT, Any}} where AT&lt;:AbstractAntennaArray" href="#MoM_Basics.update_phase!-Union{Tuple{AT}, Tuple{AT, Any}} where AT&lt;:AbstractAntennaArray"><code>MoM_Basics.update_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_phase!(ary::AT, phase) where {AT&lt;:AbstractAntennaArray}</code></pre><p>更新指向相位</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.update_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real" href="#MoM_Basics.update_phase!-Union{Tuple{FT}, Tuple{MagneticDipole{FT}, Any}} where FT&lt;:Real"><code>MoM_Basics.update_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_phase!(md::MagneticDipole{FT}, phase) where {FT &lt;: Real}</code></pre><p>设置磁偶极 <code>md</code> 的相位为 <code>phase</code>。</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.θϕInfofromCart-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Basics.θϕInfofromCart-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Basics.θϕInfofromCart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">θϕInfofromCart(rvec::Vec3D{FT}) where {FT&lt;:Real}</code></pre><p>从直角坐标 <code>rvec</code> 计算三角函数：<span>$sinθ, cosθ, sinϕ, cosϕ$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MoM_Basics.@clock-Tuple{Any, Any}" href="#MoM_Basics.@clock-Tuple{Any, Any}"><code>MoM_Basics.@clock</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">clock(message, ex)</code></pre><p>将表达式 <code>ex</code> 的运行时间以 <code>message</code> 为键保存在字典 <code>timer</code> 中。</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 8 June 2023 09:30">Thursday 8 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
